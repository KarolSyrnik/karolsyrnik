<!doctype html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Karteikarten (offline)</title>
  <style>
    :root{
      --bg:#f5f6f8;
      --panel:#ffffff;
      --text:#111;
      --muted:#666;
      --border:#d9dde3;
      --shadow: 0 10px 30px rgba(0,0,0,.12);
      --btn:#111;
      --btnText:#fff;
      --danger:#c62828;
      --accent:#111;
      --focus: rgba(17,17,17,.14);
    }
    [data-theme="dark"]{
      --bg:#000;
      --panel:#0f0f10;
      --text:#fff;
      --muted:#b8b8b8;
      --border:#2a2a2a;
      --shadow: 0 10px 30px rgba(0,0,0,.65);
      --btn:#fff;
      --btnText:#000;
      --danger:#ff5b5b;
      --accent:#fff;
      --focus: rgba(255,255,255,.14);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      overflow-x:hidden;
    }

    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
    }

    /* Top bar */
    .topbar{
      position:sticky;
      top:0;
      z-index:20;
      background:var(--bg);
      padding:12px 12px 10px;
    }
    .topbar-inner{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      max-width:1100px;
      margin:0 auto;
    }
    .group{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      min-width:0;
    }

    .btn{
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      border-radius:14px;
      padding:10px 12px;
      font-size:14px;
      line-height:1;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.primary{
      background:var(--btn);
      color:var(--btnText);
      border-color:transparent;
    }
    .btn.icon{
      width:42px;
      height:42px;
      justify-content:center;
      padding:0;
      border-radius:14px;
    }
    .btn:active{ transform: translateY(1px); }
    .btn:focus-visible{
      outline: none;
      box-shadow: 0 0 0 4px var(--focus);
    }

    /* Icons (no emojis) */
    .ico{
      width:18px;
      height:18px;
      display:inline-block;
      vertical-align:middle;
      color: currentColor;
    }
    .ico.big{
      width:20px;
      height:20px;
    }
    .ico.small{
      width:16px;
      height:16px;
    }
    .stroke{
      fill:none;
      stroke:currentColor;
      stroke-width:2;
      stroke-linecap:round;
      stroke-linejoin:round;
    }
    .fill{
      fill: currentColor;
    }

    /* Custom dropdown (so we can have per-item buttons) */
    .dd{
      position:relative;
      width: min(520px, 78vw);
      max-width: min(560px, 84vw);
      min-width: min(320px, 74vw);
    }
    .dd-btn{
      width:100%;
      justify-content:space-between;
      padding:12px 12px 12px 14px;
      border-radius:16px;
    }
    .dd-btn .left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .dd-btn .name{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-weight:650;
    }
    .dd-btn .meta{
      color:var(--muted);
      font-size:12px;
      font-weight:600;
      white-space:nowrap;
    }
    .dd-btn .caret{
      color:var(--muted);
      font-size:14px;
      margin-left:10px;
    }

    .dd-menu{
      position:absolute;
      left:0;
      right:0;
      top: calc(100% + 10px);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius:18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:none;
      max-height: min(56vh, 420px);
    }
    .dd.open .dd-menu{ display:block; }

    .dd-list{
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      max-height: min(56vh, 420px);
    }

    .dd-item{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 10px;
      border-bottom:1px solid var(--border);
    }
    .dd-item:last-child{ border-bottom:none; }

    .dd-item-main{
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:2px;
      cursor:pointer;
      padding:6px 8px;
      border-radius:14px;
      -webkit-tap-highlight-color: transparent;
    }
    .dd-item-main:hover{
      background: rgba(0,0,0,.04);
    }
    [data-theme="dark"] .dd-item-main:hover{
      background: rgba(255,255,255,.06);
    }

    .dd-item-title{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .dd-item-title .tname{
      font-weight:750;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color: var(--muted);
      font-weight:700;
      border: 1px solid var(--border);
      padding: 3px 8px;
      border-radius:999px;
      background: transparent;
      flex: 0 0 auto;
    }

    .dd-item-sub{
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .dd-actions{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .mini{
      width:40px;
      height:40px;
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      border:1px solid var(--border);
      background: transparent;
      color: var(--text);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .mini:hover{
      background: rgba(0,0,0,.04);
    }
    [data-theme="dark"] .mini:hover{
      background: rgba(255,255,255,.06);
    }
    .mini.danger{
      color: var(--danger);
      border-color: transparent;
    }
    .mini.danger:hover{
      background: rgba(198,40,40,.08);
    }
    [data-theme="dark"] .mini.danger:hover{
      background: rgba(255,91,91,.10);
    }

    .dd-footer{
      padding:10px;
      border-top:1px solid var(--border);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .dd-footer .small{
      color:var(--muted);
      font-size:12px;
    }

    .hint{
      max-width:1100px;
      margin:6px auto 0;
      padding:0 2px;
      color:var(--muted);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    /* Main stage */
    .stage{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px 10px 24px;
    }

    .nav{
      display:flex;
      align-items:center;
      justify-content:center;
      width: min(18vw, 120px);
      min-width: 54px;
      height: min(70vh, 520px);
    }
    .arrow{
      border:none;
      background:transparent;
      color:var(--accent);
      font-size: min(9vh, 70px);
      line-height:1;
      cursor:pointer;
      padding: 12px 8px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .arrow.left{ transform: scaleX(-1); }
    .arrow[disabled]{ opacity:.25; cursor:default; }

    .center{
      display:flex;
      align-items:center;
      justify-content:center;
      width: min(92vw, 860px);
    }

    /* Card */
    .card-wrap{
      perspective: 1200px;
      width: 14cm;
      height: 10cm;
      max-width: 92vw;
      max-height: 66vh;
      aspect-ratio: 14 / 10;
    }
    .card{
      width:100%;
      height:100%;
      position:relative;
      transform-style:preserve-3d;
      transition: transform .55s cubic-bezier(.2,.8,.2,1);
      border-radius:20px;
      box-shadow: var(--shadow);
    }
    .card.flipped{ transform: rotateY(180deg); }

    .face{
      position:absolute;
      inset:0;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:20px;
      backface-visibility:hidden;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .face.back{ transform: rotateY(180deg); }

    .header{
      height: 44px;
      min-height:44px;
      display:flex;
      align-items:center;
      padding: 0 14px 0 54px;
      border-bottom:1px solid var(--border);
      font-weight:800;
      letter-spacing:.2px;
      color:var(--text);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .content-area{
      position:relative;
      flex:1;
      display:flex;
      min-height:0;
    }

    /* Vertical label on left edge, centered */
    .side-label{
      position:absolute;
      left: 10px;
      top:50%;
      transform: translateY(-50%) rotate(180deg);
      writing-mode: vertical-rl;
      font-weight:900;
      letter-spacing: .8px;
      font-size: 12px;
      color: var(--muted);
      user-select:none;
      pointer-events:none;
    }

    .scroll{
      flex:1;
      padding: 12px 14px 10px 54px;
      overflow-y: scroll;                 /* ALWAYS show scrollbar */
      -webkit-overflow-scrolling: touch;  /* iPhone smooth scroll */
      scrollbar-gutter: stable;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:12px;
      min-height:0;
    }

    .main-text{
      font-size: 18px;
      line-height:1.35;
      text-align:center;
      color: var(--text);
      word-break: break-word;
      white-space: pre-wrap;
    }

    .inline-img{
      width: 100%;
      max-width: 100%;
      height:auto;
      max-height: 260px;
      object-fit: contain;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: transparent;
    }

    .difficulty{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      margin-top: 2px;
    }
    .dot{
      width:12px;
      height:12px;
      border-radius:999px;
      border: 2px solid var(--muted);
      opacity:.85;
    }
    .dot.filled{
      border-color: var(--accent);
      background: var(--accent);
      opacity:1;
    }

    .footer{
      height: 54px;
      min-height:54px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 0 14px 0 14px;
      border-top:1px solid var(--border);
      color:var(--muted);
      font-size:12px;
      gap:12px;
    }
    .footer .meta{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      min-width:0;
    }
    .kbd{
      border:1px solid var(--border);
      border-bottom-width:2px;
      padding:2px 6px;
      border-radius:8px;
      font-size:11px;
      color:var(--muted);
      background: var(--panel);
      white-space:nowrap;
    }

    /* Empty state */
    .empty{
      text-align:center;
      color:var(--muted);
      padding: 18px;
      border:1px dashed var(--border);
      border-radius:18px;
      width:min(520px, 92vw);
      background: transparent;
    }

    /* Mobile tweaks */
    @media (max-width: 520px){
      .topbar{ padding: 10px 10px 8px; }
      .dd{ min-width: 62vw; }
      .btn{ padding: 10px 10px; }
      .btn.icon{ width:40px; height:40px; }
      .arrow{ font-size: 56px; }
      .header{ height: 42px; min-height:42px; font-size: 14px; padding-left: 50px; }
      .scroll{ padding-left: 50px; }
      .main-text{ font-size: 16px; }
      .inline-img{ max-height: 180px; }
      .side-label{ left: 9px; font-size: 11px; }
      .footer{ height: 52px; min-height:52px; }
      .mini{ width:38px; height:38px; }
    }
  </style>
</head>
<body>
<div class="app" id="app">
  <div class="topbar">
    <div class="topbar-inner">
      <div class="group" style="flex:1;">
        <!-- Custom dropdown -->
        <div class="dd" id="dd">
          <button class="btn dd-btn" id="ddBtn" type="button" aria-haspopup="listbox" aria-expanded="false">
            <div class="left">
              <span id="ddTitle" class="name">Keine TXT geladen</span>
              <span id="ddMeta" class="meta"></span>
            </div>
            <span class="caret">▾</span>
          </button>

          <div class="dd-menu" id="ddMenu">
            <div class="dd-list" id="ddList"></div>
            <div class="dd-footer">
              <div class="small">Jede TXT hat ihre eigenen Bilder (IndexedDB).</div>
              <button class="btn primary" id="btnUploadTxt" type="button">
                <span>TXT Upload</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="group">
        <button class="btn icon" id="btnTheme" type="button" title="Theme wechseln">
          <!-- theme icon will be injected -->
          <span id="themeIcon"></span>
        </button>
      </div>
    </div>

    <div class="hint">
      <div id="statusLeft">Offline • Lokal gespeichert</div>
      <div id="statusRight" style="text-align:right;">Klick Karte = Flip • Pfeile = Navigieren</div>
    </div>
  </div>

  <div class="stage">
    <div class="nav">
      <button class="arrow left" id="prevBtn" type="button" aria-label="Vorherige Karte">➜</button>
    </div>

    <div class="center">
      <div id="emptyState" class="empty" style="display:none;">
        <div style="font-weight:900; color:var(--text); margin-bottom:6px;">Keine Karteikarten</div>
        <div>Upload eine oder mehrere <b>.txt</b> Dateien.</div>
        <div style="margin-top:10px; font-size:12px;">
          Bilder pro TXT: Bild-Button • Marker: <b>#Test#</b> (case-insensitive)
        </div>
      </div>

      <div class="card-wrap" id="cardWrap" style="display:none;">
        <div class="card" id="card" role="button" aria-label="Karte umdrehen" tabindex="0">
          <div class="face front">
            <div class="header" id="topicFront">Thema</div>
            <div class="content-area">
              <div class="side-label">Frage</div>
              <div class="scroll" id="scrollFront">
                <div class="main-text" id="textFront"></div>
                <div class="difficulty" id="diffFront">
                  <div class="dot"></div><div class="dot"></div><div class="dot"></div>
                </div>
              </div>
            </div>
            <div class="footer">
              <div class="meta" id="metaFront">—</div>
              <div class="kbd">← / →</div>
            </div>
          </div>

          <div class="face back">
            <div class="header" id="topicBack">Thema</div>
            <div class="content-area">
              <div class="side-label">Antwort</div>
              <div class="scroll" id="scrollBack">
                <div class="main-text" id="textBack"></div>
                <div class="difficulty" id="diffBack">
                  <div class="dot"></div><div class="dot"></div><div class="dot"></div>
                </div>
              </div>
            </div>
            <div class="footer">
              <div class="meta" id="metaBack">—</div>
              <div class="kbd">Esc = Flip</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="nav">
      <button class="arrow" id="nextBtn" type="button" aria-label="Nächste Karte">➜</button>
    </div>
  </div>
</div>

<!-- Hidden inputs -->
<input id="txtInput" type="file" accept=".txt,text/plain" multiple style="display:none;" />
<input id="imgInput" type="file" accept="image/*" multiple style="display:none;" />

<script>
(() => {
  const LS_LIST_KEY = "fc_txt_list_v3";
  const LS_THEME_KEY = "fc_theme_v1";
  const LS_LAST_TXT_KEY = "fc_last_txt_v1";
  const LS_CONTENT_PREFIX = "fc_txt_content_v1_";

  // Elements
  const dd = document.getElementById("dd");
  const ddBtn = document.getElementById("ddBtn");
  const ddMenu = document.getElementById("ddMenu");
  const ddList = document.getElementById("ddList");
  const ddTitle = document.getElementById("ddTitle");
  const ddMeta = document.getElementById("ddMeta");

  const btnUploadTxt = document.getElementById("btnUploadTxt");
  const btnTheme = document.getElementById("btnTheme");
  const themeIcon = document.getElementById("themeIcon");
  const txtInput = document.getElementById("txtInput");
  const imgInput = document.getElementById("imgInput");

  const emptyState = document.getElementById("emptyState");
  const cardWrap = document.getElementById("cardWrap");
  const cardEl = document.getElementById("card");
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");

  const topicFront = document.getElementById("topicFront");
  const topicBack = document.getElementById("topicBack");
  const textFront = document.getElementById("textFront");
  const textBack = document.getElementById("textBack");
  const diffFront = document.getElementById("diffFront");
  const diffBack = document.getElementById("diffBack");
  const metaFront = document.getElementById("metaFront");
  const metaBack = document.getElementById("metaBack");
  const statusLeft = document.getElementById("statusLeft");

  // State
  let txtList = []; // {id,name,addedAt,hasImages:boolean,imgCount:number}
  let currentTxtId = "";
  let currentTxtName = "";
  let cards = [];
  let idx = 0;
  let isFlipped = false;

  // ---------- Inline SVG icons (no emojis) ----------
  function svgCamera(){
    return `
      <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
        <path class="stroke" d="M4 7h3l2-2h6l2 2h3a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V11a2 2 0 0 1 2-2z"/>
        <circle class="stroke" cx="12" cy="15" r="3.5"/>
      </svg>
    `;
  }
  function svgTrash(){
    return `
      <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
        <path class="stroke" d="M4 7h16"/>
        <path class="stroke" d="M10 11v7"/>
        <path class="stroke" d="M14 11v7"/>
        <path class="stroke" d="M6 7l1 14a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2l1-14"/>
        <path class="stroke" d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"/>
      </svg>
    `;
  }
  function svgSun(){
    return `
      <svg class="ico big" viewBox="0 0 24 24" aria-hidden="true">
        <circle class="stroke" cx="12" cy="12" r="4"/>
        <path class="stroke" d="M12 2v2"/>
        <path class="stroke" d="M12 20v2"/>
        <path class="stroke" d="M4.93 4.93l1.41 1.41"/>
        <path class="stroke" d="M17.66 17.66l1.41 1.41"/>
        <path class="stroke" d="M2 12h2"/>
        <path class="stroke" d="M20 12h2"/>
        <path class="stroke" d="M4.93 19.07l1.41-1.41"/>
        <path class="stroke" d="M17.66 6.34l1.41-1.41"/>
      </svg>
    `;
  }
  function svgMoon(){
    return `
      <svg class="ico big" viewBox="0 0 24 24" aria-hidden="true">
        <path class="stroke" d="M21 14.5A7.5 7.5 0 0 1 9.5 3a6.5 6.5 0 1 0 11.5 11.5z"/>
      </svg>
    `;
  }
  function svgImageBadge(){
    return `
      <span class="badge" title="Diese TXT hat Bilder">
        ${svgCamera()}
        <span>Bilder</span>
      </span>
    `;
  }

  // ---------- IndexedDB for images ----------
  const DB_NAME = "flashcards_images_v3";
  const DB_VERSION = 1;
  const STORE = "images";

  function openDB(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE)) {
          const store = db.createObjectStore(STORE, { keyPath: "key" });
          store.createIndex("byTxt", "txtId", { unique: false });
          store.createIndex("byTxtName", ["txtId","name"], { unique: true });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbPutImage(txtId, nameLower, blob, mime){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      const store = tx.objectStore(STORE);
      store.put({
        key: `${txtId}::${nameLower}`,
        txtId,
        name: nameLower,
        blob,
        mime: mime || (blob && blob.type) || "application/octet-stream",
        addedAt: Date.now()
      });
      tx.oncomplete = () => { db.close(); resolve(true); };
      tx.onerror = () => { const e = tx.error; db.close(); reject(e); };
    });
  }

  async function idbGetImage(txtId, nameLower){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readonly");
      const store = tx.objectStore(STORE);
      const req = store.get(`${txtId}::${nameLower}`);
      req.onsuccess = () => { const r = req.result; db.close(); resolve(r || null); };
      req.onerror = () => { const e = req.error; db.close(); reject(e); };
    });
  }

  async function idbDeleteImagesForTxt(txtId){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      const store = tx.objectStore(STORE);
      const idxByTxt = store.index("byTxt");
      const range = IDBKeyRange.only(txtId);
      const req = idxByTxt.openCursor(range);
      req.onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor) {
          store.delete(cursor.primaryKey);
          cursor.continue();
        }
      };
      tx.oncomplete = () => { db.close(); resolve(true); };
      tx.onerror = () => { const e = tx.error; db.close(); reject(e); };
    });
  }

  async function idbCountImagesForTxt(txtId){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readonly");
      const store = tx.objectStore(STORE);
      const idxByTxt = store.index("byTxt");
      const range = IDBKeyRange.only(txtId);

      let count = 0;
      const req = idxByTxt.openCursor(range);
      req.onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor){
          count++;
          cursor.continue();
        }
      };
      tx.oncomplete = () => { db.close(); resolve(count); };
      tx.onerror = () => { const e = tx.error; db.close(); reject(e); };
    });
  }

  // ---------- LocalStorage for TXT ----------
  function loadTxtList(){
    try{
      const raw = localStorage.getItem(LS_LIST_KEY);
      txtList = raw ? JSON.parse(raw) : [];
      if (!Array.isArray(txtList)) txtList = [];
    }catch{
      txtList = [];
    }
  }
  function saveTxtList(){
    localStorage.setItem(LS_LIST_KEY, JSON.stringify(txtList));
  }
  function saveTxtContent(id, content){
    localStorage.setItem(LS_CONTENT_PREFIX + id, content);
  }
  function getTxtContent(id){
    return localStorage.getItem(LS_CONTENT_PREFIX + id) || "";
  }
  function deleteTxtContent(id){
    localStorage.removeItem(LS_CONTENT_PREFIX + id);
  }

  function makeId(){
    return "t" + Date.now().toString(36) + Math.random().toString(36).slice(2,8);
  }

  // ---------- Robust Parser ----------
  function parseTXT(raw){
    const text = (raw || "").replace(/\r\n?/g, "\n");
    const lines = text.split("\n");

    const keyMap = [
      { re: /^frage\s*:\s*(.*)$/i, key: "frage", multi:false },
      { re: /^schwierigkeit\s*:\s*(.*)$/i, key: "schwierigkeit", multi:false },
      { re: /^thema\s*:\s*(.*)$/i, key: "thema", multi:false },
      { re: /^text\s*:\s*(.*)$/i, key: "text", multi:true },
      { re: /^lösungs-?titel\s*:\s*(.*)$/i, key: "loesungstitel", multi:false },
      { re: /^lösung\s*:\s*(.*)$/i, key: "loesung", multi:true },
    ];

    const cards = [];
    let cur = null;
    let mode = null;

    function ensureCard(){
      if (!cur) {
        cur = { frageNr:"", schwierigkeit:1, thema:"", text:"", loesungstitel:"", loesung:"" };
      }
    }
    function pushCardIfValid(){
      if (!cur) return;
      const hasAny =
        (cur.text && cur.text.trim()) ||
        (cur.loesung && cur.loesung.trim()) ||
        (cur.thema && cur.thema.trim()) ||
        (cur.frageNr && String(cur.frageNr).trim());
      if (hasAny) {
        let d = parseInt(String(cur.schwierigkeit || "1"), 10);
        if (!Number.isFinite(d)) d = 1;
        d = Math.max(1, Math.min(3, d));
        cur.schwierigkeit = d;

        cur.text = (cur.text || "").trimEnd();
        cur.loesung = (cur.loesung || "").trimEnd();
        cur.thema = (cur.thema || "").trim();
        cur.loesungstitel = (cur.loesungstitel || "").trim();
        cur.frageNr = (cur.frageNr || "").toString().trim();
        cards.push(cur);
      }
      cur = null;
      mode = null;
    }

    function takeNextNonEmptyValue(startIndex){
      for (let j = startIndex; j < lines.length; j++){
        const v = (lines[j] ?? "").trim();
        if (v !== "") return { value: lines[j], index: j };
      }
      return { value: "", index: startIndex };
    }

    for (let i = 0; i < lines.length; i++){
      const line = lines[i];

      let matched = null;
      for (const km of keyMap){
        const m = line.match(km.re);
        if (m){
          matched = { ...km, value: (m[1] ?? "") };
          break;
        }
      }

      if (matched){
        if (matched.key === "frage"){
          if (cur) pushCardIfValid();
          ensureCard();
          let val = (matched.value || "").trim();
          if (!val){
            const nx = takeNextNonEmptyValue(i+1);
            val = (nx.value || "").trim();
            if (nx.index > i) i = nx.index;
          }
          cur.frageNr = val;
          mode = null;
          continue;
        }

        ensureCard();

        let val = matched.value;
        if ((val || "").trim() === ""){
          const nx = takeNextNonEmptyValue(i+1);
          val = nx.value || "";
          if (nx.index > i) i = nx.index;
        }

        if (matched.multi){
          mode = matched.key;
          cur[matched.key] = (val ?? "");
        } else {
          mode = null;
          if (matched.key === "schwierigkeit") cur.schwierigkeit = (val || "").trim();
          else cur[matched.key] = (val ?? "");
        }
        continue;
      }

      if (mode === "text" || mode === "loesung"){
        ensureCard();
        const existing = cur[mode] || "";
        cur[mode] = existing === "" ? line : (existing + "\n" + line);
      }
    }

    if (cur) pushCardIfValid();

    if (cards.length === 0 && text.trim()){
      cards.push({ frageNr:"", schwierigkeit:1, thema:"", text:text.trim(), loesungstitel:"", loesung:"" });
    }
    return cards;
  }

  // ---------- Marker rendering (#Name# => image) ----------
  function clearNode(node){
    while(node.firstChild) node.removeChild(node.firstChild);
  }
  function getMarkerParts(str){
    const s = String(str ?? "");
    const parts = [];
    const re = /#([^#]+)#/g;
    let last = 0;
    let m;
    while ((m = re.exec(s)) !== null){
      if (m.index > last) parts.push({ type:"text", value: s.slice(last, m.index) });
      parts.push({ type:"marker", value: (m[1] || "").trim() });
      last = m.index + m[0].length;
    }
    if (last < s.length) parts.push({ type:"text", value: s.slice(last) });
    return parts;
  }

  async function renderMixedFlow(targetEl, rawText){
    clearNode(targetEl);

    const flow = document.createElement("div");
    flow.style.display = "flex";
    flow.style.flexDirection = "column";
    flow.style.gap = "12px";
    flow.style.alignItems = "center";
    flow.style.justifyContent = "center";

    const parts = getMarkerParts(rawText);

    for (const p of parts){
      if (p.type === "text"){
        const t = p.value;
        if (t !== ""){
          const block = document.createElement("div");
          block.className = "main-text";
          block.textContent = t;
          flow.appendChild(block);
        }
      } else {
        const nameLower = String(p.value || "").toLowerCase();
        if (!nameLower || !currentTxtId) continue;

        try{
          const rec = await idbGetImage(currentTxtId, nameLower);
          if (rec && rec.blob){
            const img = document.createElement("img");
            img.className = "inline-img";
            img.alt = p.value;
            img.decoding = "async";
            img.loading = "lazy";
            const url = URL.createObjectURL(rec.blob);
            img.src = url;
            img.addEventListener("load", () => {
              setTimeout(() => URL.revokeObjectURL(url), 8000);
            }, { once:true });
            flow.appendChild(img);
          }
        }catch{}
      }
    }

    if (!flow.childNodes.length){
      const block = document.createElement("div");
      block.className = "main-text";
      block.textContent = "";
      flow.appendChild(block);
    }

    targetEl.appendChild(flow);
  }

  function setDots(container, difficulty){
    const dots = [...container.querySelectorAll(".dot")];
    dots.forEach((d, i) => d.classList.toggle("filled", i < difficulty));
  }

  function setEmptyUI(isEmpty){
    emptyState.style.display = isEmpty ? "block" : "none";
    cardWrap.style.display = isEmpty ? "none" : "block";
    prevBtn.disabled = isEmpty;
    nextBtn.disabled = isEmpty;
  }

  function clampIndex(){
    if (idx < 0) idx = 0;
    if (idx >= cards.length) idx = Math.max(0, cards.length - 1);
  }

  function updateNavButtons(){
    prevBtn.disabled = !cards.length || idx <= 0;
    nextBtn.disabled = !cards.length || idx >= cards.length - 1;
  }

  async function renderCard(){
    if (!cards.length){
      setEmptyUI(true);
      statusLeft.textContent = "Offline • Lokal gespeichert";
      return;
    }
    setEmptyUI(false);
    clampIndex();
    updateNavButtons();

    const c = cards[idx] || {};
    const topic = (c.thema || "—").trim() || "—";
    topicFront.textContent = topic;
    topicBack.textContent = topic;

    const qText = (c.text || "").trim();
    const aTitle = (c.loesungstitel || "").trim();
    const aTextRaw = (c.loesung || "").trim();
    const answerCombined = (aTitle ? (aTitle + "\n\n") : "") + aTextRaw;

    setDots(diffFront, c.schwierigkeit || 1);
    setDots(diffBack, c.schwierigkeit || 1);

    metaFront.textContent = `Karte ${idx+1} / ${cards.length}` + (c.frageNr ? ` • Frage: ${c.frageNr}` : "");
    metaBack.textContent  = `Karte ${idx+1} / ${cards.length}` + (c.frageNr ? ` • Frage: ${c.frageNr}` : "");

    if (isFlipped){
      isFlipped = false;
      cardEl.classList.remove("flipped");
    }

    await renderMixedFlow(textFront, qText);
    await renderMixedFlow(textBack, answerCombined);

    const meta = txtList.find(t => t.id === currentTxtId);
    const imgCount = meta?.imgCount || 0;
    statusLeft.textContent = `Offline • TXT: ${currentTxtName || "—"} • Bilder: ${imgCount}`;
  }

  function flip(){
    if (!cards.length) return;
    isFlipped = !isFlipped;
    cardEl.classList.toggle("flipped", isFlipped);
  }

  function prev(){ if (idx > 0){ idx--; renderCard(); } }
  function next(){ if (idx < cards.length - 1){ idx++; renderCard(); } }

  // ---------- Theme ----------
  function setThemeIcon(){
    const cur = document.documentElement.getAttribute("data-theme") || "light";
    themeIcon.innerHTML = (cur === "dark") ? svgSun() : svgMoon();
  }
  function applyTheme(theme){
    const t = theme === "dark" ? "dark" : "light";
    document.documentElement.setAttribute("data-theme", t);
    localStorage.setItem(LS_THEME_KEY, t);
    setThemeIcon();
  }

  btnTheme.addEventListener("click", () => {
    const cur = document.documentElement.getAttribute("data-theme") || "light";
    applyTheme(cur === "dark" ? "light" : "dark");
  });

  // ---------- Custom dropdown ----------
  function closeDD(){
    dd.classList.remove("open");
    ddBtn.setAttribute("aria-expanded", "false");
  }
  function openDD(){
    dd.classList.add("open");
    ddBtn.setAttribute("aria-expanded", "true");
  }
  ddBtn.addEventListener("click", () => {
    dd.classList.contains("open") ? closeDD() : openDD();
  });
  window.addEventListener("click", (e) => {
    if (!dd.contains(e.target)) closeDD();
  });
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") closeDD();
  });

  function setDDHeader(){
    if (!currentTxtId){
      ddTitle.textContent = "Keine TXT geladen";
      ddMeta.textContent = "";
      return;
    }
    const meta = txtList.find(t => t.id === currentTxtId);
    ddTitle.textContent = currentTxtName || "—";
    const imgCount = meta?.imgCount || 0;
    ddMeta.textContent = `${cards.length} Karten • ${imgCount} Bilder`;
  }

  async function refreshTxtMetaFromDB(){
    for (const t of txtList){
      try{
        const c = await idbCountImagesForTxt(t.id);
        t.imgCount = c;
        t.hasImages = c > 0;
      }catch{
        t.imgCount = t.imgCount || 0;
        t.hasImages = (t.imgCount || 0) > 0;
      }
    }
    saveTxtList();
  }

  function renderDDList(){
    ddList.innerHTML = "";

    if (!txtList.length){
      const div = document.createElement("div");
      div.style.padding = "14px";
      div.style.color = "var(--muted)";
      div.style.fontSize = "13px";
      div.textContent = "Noch keine TXT gespeichert.";
      ddList.appendChild(div);
      return;
    }

    for (const t of txtList){
      const item = document.createElement("div");
      item.className = "dd-item";

      const main = document.createElement("div");
      main.className = "dd-item-main";
      main.setAttribute("role","option");
      main.setAttribute("aria-selected", t.id === currentTxtId ? "true" : "false");

      const title = document.createElement("div");
      title.className = "dd-item-title";

      const name = document.createElement("div");
      name.className = "tname";
      name.textContent = t.name;

      title.appendChild(name);

      if (t.hasImages){
        const badgeWrap = document.createElement("div");
        badgeWrap.innerHTML = svgImageBadge();
        title.appendChild(badgeWrap.firstElementChild);
      }

      const sub = document.createElement("div");
      sub.className = "dd-item-sub";
      const imgCount = t.imgCount || 0;
      sub.textContent = `Bilder: ${imgCount} • hinzugefügt: ${new Date(t.addedAt || Date.now()).toLocaleDateString()}`;

      main.appendChild(title);
      main.appendChild(sub);

      main.addEventListener("click", async () => {
        await selectTxt(t.id);
        closeDD();
      });

      const actions = document.createElement("div");
      actions.className = "dd-actions";

      const btnImg = document.createElement("button");
      btnImg.className = "mini";
      btnImg.type = "button";
      btnImg.title = "Bilder zu dieser TXT hochladen";
      btnImg.innerHTML = svgCamera();
      btnImg.addEventListener("click", (ev) => {
        ev.stopPropagation();
        startImageUploadForTxt(t.id);
      });

      const btnDel = document.createElement("button");
      btnDel.className = "mini danger";
      btnDel.type = "button";
      btnDel.title = "TXT + Bilder löschen";
      btnDel.innerHTML = svgTrash();
      btnDel.addEventListener("click", async (ev) => {
        ev.stopPropagation();
        await deleteTxt(t.id);
      });

      actions.appendChild(btnImg);
      actions.appendChild(btnDel);

      item.appendChild(main);
      item.appendChild(actions);
      ddList.appendChild(item);
    }
  }

  // ---------- Select TXT ----------
  async function selectTxt(id){
    currentTxtId = id || "";
    const meta = txtList.find(t => t.id === currentTxtId);
    currentTxtName = meta ? meta.name : "";

    if (!currentTxtId){
      cards = [];
      idx = 0;
      setDDHeader();
      await renderCard();
      return;
    }

    localStorage.setItem(LS_LAST_TXT_KEY, currentTxtId);

    const content = getTxtContent(currentTxtId);
    cards = parseTXT(content);
    idx = 0;

    setDDHeader();
    await renderCard();
  }

  // ---------- Upload TXT ----------
  btnUploadTxt.addEventListener("click", () => txtInput.click());

  txtInput.addEventListener("change", async () => {
    const files = [...(txtInput.files || [])].filter(f => f);
    if (!files.length) return;

    for (const f of files){
      const text = await f.text();
      const id = makeId();
      const name = f.name || ("Upload " + new Date().toLocaleString());
      txtList.unshift({ id, name, addedAt: Date.now(), hasImages:false, imgCount:0 });
      saveTxtContent(id, text);
    }

    saveTxtList();
    await refreshTxtMetaFromDB();
    renderDDList();

    await selectTxt(txtList[0].id);
    closeDD();

    txtInput.value = "";
  });

  // ---------- Upload Images for specific TXT ----------
  let pendingImageUploadTxtId = null;

  function filenameNoExt(name){
    const s = String(name || "");
    const base = s.split("/").pop().split("\\").pop();
    const dot = base.lastIndexOf(".");
    return (dot > 0 ? base.slice(0, dot) : base).trim();
  }

  function startImageUploadForTxt(txtId){
    pendingImageUploadTxtId = txtId;
    imgInput.click();
  }

  imgInput.addEventListener("change", async () => {
    const files = [...(imgInput.files || [])].filter(f => f && f.type && f.type.startsWith("image/"));
    if (!files.length) return;
    const txtId = pendingImageUploadTxtId || currentTxtId;
    if (!txtId) return;

    let count = 0;
    for (const f of files){
      const markerName = filenameNoExt(f.name).toLowerCase();
      if (!markerName) continue;
      try{
        const blob = f.slice(0, f.size, f.type);
        await idbPutImage(txtId, markerName, blob, f.type);
        count++;
      }catch(e){
        console.warn("Image save failed:", e);
      }
    }

    pendingImageUploadTxtId = null;
    imgInput.value = "";

    if (count){
      await refreshTxtMetaFromDB();
      renderDDList();
      setDDHeader();

      if (txtId === currentTxtId){
        await renderCard();
      }
    }
  });

  // ---------- Delete TXT (and its images) ----------
  async function deleteTxt(txtId){
    const meta = txtList.find(t => t.id === txtId);
    const name = meta?.name || txtId;

    const ok = confirm(`TXT "${name}" wirklich löschen?\n(inkl. aller zugehörigen Bilder)`);
    if (!ok) return;

    deleteTxtContent(txtId);
    txtList = txtList.filter(t => t.id !== txtId);
    saveTxtList();

    try{ await idbDeleteImagesForTxt(txtId); }catch(e){ console.warn(e); }

    await refreshTxtMetaFromDB();
    renderDDList();

    if (currentTxtId === txtId){
      const nextId = txtList[0]?.id || "";
      await selectTxt(nextId);
    } else {
      setDDHeader();
      await renderCard();
    }
  }

  // ---------- Card interactions ----------
  cardEl.addEventListener("click", () => flip());
  cardEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " "){
      e.preventDefault();
      flip();
    }
  });

  prevBtn.addEventListener("click", () => { if (idx > 0){ idx--; renderCard(); } });
  nextBtn.addEventListener("click", () => { if (idx < cards.length - 1){ idx++; renderCard(); } });

  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft"){ if (idx > 0){ idx--; renderCard(); } }
    else if (e.key === "ArrowRight"){ if (idx < cards.length - 1){ idx++; renderCard(); } }
    else if (e.key === "Escape") flip();
  });

  // ---------- Init ----------
  async function init(){
    const savedTheme = localStorage.getItem(LS_THEME_KEY) || "light";
    applyTheme(savedTheme);

    loadTxtList();
    await refreshTxtMetaFromDB();
    renderDDList();

    const last = localStorage.getItem(LS_LAST_TXT_KEY) || "";
    const initialId = (last && txtList.some(t => t.id === last)) ? last : (txtList[0]?.id || "");
    await selectTxt(initialId);

    setDDHeader();
    setThemeIcon();
  }

  init();
})();
</script>
</body>
</html>
