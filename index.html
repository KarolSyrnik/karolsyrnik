<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<title>Karteikarten</title>
<meta name="viewport" content="width=device-width,initial-scale=1">

<style>
:root{
  --bg:#f2f2f2;
  --card:#ffffff;
  --text:#1a1a1a;
  --bar:#d9d9d9;
  --border:#cfcfcf;
  --shadow:0 16px 65px rgba(0,0,0,.25);

  --ui:#ffffff;
  --uiBorder:#d0d0d0;
  --uiHover:#f3f3f3;
}
[data-theme="dark"]{
  --bg:#000000;
  --card:#0b0b0b;
  --text:#eaeaea;
  --bar:#1a1a1a;
  --border:#2a2a2a;
  --shadow:0 22px 80px rgba(0,0,0,.85);

  --ui:#0c0c0c;
  --uiBorder:#2a2a2a;
  --uiHover:#141414;
}

*{box-sizing:border-box}
body{
  margin:0;
  min-height:100vh;
  background:var(--bg);
  font-family:system-ui,Segoe UI,Arial;
  display:flex;
  justify-content:center;
  align-items:center;
  color:var(--text);
}

.page{width:100%}
.top{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:18px 28px;
}
.controls{
  display:flex;
  gap:12px;
  align-items:center;
  flex-wrap:wrap;
}
#counter{font-weight:900; opacity:.75}

/* UI */
.btn{
  background:var(--ui);
  color:var(--text);
  border:1px solid var(--uiBorder);
  border-radius:14px;
  padding:10px 16px;
  font-weight:900;
  cursor:pointer;
  transition:.15s;
}
.btn:hover{background:var(--uiHover)}
.btn:active{transform:scale(.98)}

/* FILE MENU */
.fileBox{
  display:flex;
  align-items:center;
  gap:10px;
  background:var(--ui);
  border:1px solid var(--uiBorder);
  border-radius:16px;
  padding:8px 10px;
  position:relative;
}
.fileBox label.pickTxt{
  padding:8px 14px;
  border-radius:12px;
  font-weight:900;
  cursor:pointer;
  background:var(--uiHover);
}
.fileBox input.txtInput{display:none}

.fileBtn{
  border:none;
  background:none;
  color:var(--text);
  font-weight:900;
  cursor:pointer;
  padding:8px 12px;
  border-radius:12px;
  display:flex;
  align-items:center;
  gap:8px;
}
.fileBtn:hover{background:var(--uiHover)}
.fileName{
  max-width:180px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

.menu{
  position:absolute;
  top:58px;
  left:0;
  width:420px;
  max-width:92vw;
  background:var(--ui);
  border:1px solid var(--uiBorder);
  border-radius:16px;
  box-shadow:0 25px 80px rgba(0,0,0,.45);
  padding:8px;
  display:none;
  z-index:999;
}
.menu.open{display:block}
.menuTitle{
  font-weight:900;
  opacity:.75;
  padding:10px 10px 8px 10px;
}
.menuItem{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:10px 10px;
  border-radius:12px;
  cursor:pointer;
  transition:.12s;
}
.menuItem:hover{background:var(--uiHover)}
.menuItemName{
  font-weight:900;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}
.menuActions{
  display:flex;
  align-items:center;
  gap:10px;
  flex-shrink:0;
}
.smallBadge{
  font-weight:900;
  opacity:.7;
  border:1px solid var(--uiBorder);
  padding:4px 8px;
  border-radius:999px;
  font-size:12px;
  user-select:none;
}

.actionBtn{
  border:none;
  background:none;
  font-size:18px;
  cursor:pointer;
  opacity:.85;
  color: var(--text);
  padding:6px 8px;
  border-radius:10px;
}
.actionBtn:hover{background:var(--uiHover); opacity:1}
[data-theme="dark"] .actionBtn{color:#fff; opacity:.95}

/* Upload label (wie TXT) */
.pickImg{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  user-select:none;
}

/* iOS sicher: input NICHT display:none */
.imgRowInput{
  position:absolute;
  left:-9999px;
  width:1px;
  height:1px;
  opacity:0;
}

/* CENTER */
.center{
  position:relative;
  width:100%;
  height:calc(100vh - 110px);
  display:flex;
  justify-content:center;
  align-items:center;
}

/* ARROWS */
.arrow{
  position:absolute;
  top:50%;
  transform:translateY(-50%);
  background:none;
  border:none;
  font-size:56px;
  font-weight:700;
  color:var(--text);
  cursor:pointer;
  opacity:.55;
  transition:.15s;
}
.arrow:hover{opacity:1}
.arrow.left{left:70px; transform:translateY(-50%) scaleX(-1)}
.arrow.right{right:70px}

/* CARD */
.card{
  width:16cm;
  height:11.5cm;
  perspective:1400px;
  max-width:92vw;
  max-height:80vh;
}
.inner{
  width:100%;
  height:100%;
  position:relative;
  transform-style:preserve-3d;
  transition:.45s;
  cursor:pointer;
}
.card.flipped .inner{transform:rotateY(180deg)}
.face{
  position:absolute;
  inset:0;
  background:var(--card);
  border:1px solid var(--border);
  box-shadow:var(--shadow);
  backface-visibility:hidden;
  overflow:hidden;
}
.back{transform:rotateY(180deg)}

/* HEADER */
.header{
  position:absolute;
  top:16px; left:16px; right:16px;
  height:36px;
  background:var(--bar);
  display:flex;
  align-items:center;
  padding:0 16px;
  font-weight:900;
  border-radius:8px;
}
.pageNo{margin-left:auto; opacity:.6}

/* VERTICAL LABEL */
.vlabel{
  position:absolute;
  left:16px;
  top:120px;
  bottom:40px;
  width:60px;
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
}
.vlabel span{
  transform:rotate(-90deg);
  font-size:34px;
  font-weight:900;
  opacity:.07;
}

/* CONTENT */
.content{
  position:absolute;
  top:110px;
  left:130px;
  right:50px;
  bottom:60px;
  overflow:auto;
  padding:12px 10px;
  display:block;
  text-align:left;

  -webkit-overflow-scrolling: touch;
}
.content::-webkit-scrollbar{width:10px}
.content::-webkit-scrollbar-thumb{
  background:rgba(0,0,0,.15);
  border-radius:10px;
}
[data-theme="dark"] .content::-webkit-scrollbar-thumb{
  background:rgba(255,255,255,.18);
}

/* SCROLL FIX */
.contentInner{
  display:flex;
  flex-direction:column;
  align-items:stretch;
  justify-content:flex-start;
  padding-top:18px;
  min-height:0;
}

.answerText{
  font-size:17px;
  line-height:1.5;
  white-space:pre-wrap;
  text-align:left;
  width:100%;
}
.answerWrap{
  width:100%;
  display:flex;
  flex-direction:column;
  gap:14px;
  text-align:left;
}
.solutionTitle{font-size:18px;font-weight:900;opacity:.95}

/* INLINE IMAGE */
.inlineImgBox{
  width:100%;
  border-radius:12px;
  border:1px solid var(--border);
  background:rgba(0,0,0,.04);
  margin:14px 0;
  padding:10px;
}
[data-theme="dark"] .inlineImgBox{background:rgba(255,255,255,.04)}
.inlineImg{
  width:100%;
  height:auto;
  display:block;
  object-fit:contain;
  max-height:260px;
}

/* MOBILE */
@media (max-width:700px){
  .top{padding:12px 12px;flex-direction:column;align-items:flex-start;gap:10px}
  .controls{width:100%;justify-content:space-between}
  #counter{width:100%;text-align:right}

  .btn{padding:8px 12px;border-radius:12px;font-size:14px}
  .fileBox{width:100%;justify-content:space-between}
  .fileName{max-width:120px}

  .center{height:calc(100vh - 150px);padding-bottom:110px}

  .card{
    width:min(94vw,16cm);
    height:calc(min(94vw,16cm) * (11.5/16));
    max-height:65vh;
  }

  .arrow{
    top:auto;
    bottom:120px;
    transform:none;
    font-size:52px;
  }
  .arrow.left{left:20px; transform:scaleX(-1)}
  .arrow.right{right:20px}

  .content{left:105px;right:24px;top:95px;bottom:50px}
  .vlabel{top:110px;width:55px}
  .vlabel span{font-size:28px}

  .answerText{font-size:15px}
  .solutionTitle{font-size:16px}
  .inlineImg{max-height:200px}

  .menu{width:92vw}
}
</style>
</head>
<body>

<div class="page">
  <div class="top">
    <div class="controls">

      <!-- TXT -->
      <div class="fileBox">
        <label class="pickTxt" for="fileInput">ðŸ“„ TXT</label>
        <input class="txtInput" type="file" id="fileInput" accept=".txt" multiple>

        <button class="fileBtn" id="fileBtn" type="button">
          <span class="fileName" id="activeFileName">TXT wÃ¤hlenâ€¦</span>
          <span>â–¾</span>
        </button>

        <div class="menu" id="menu">
          <div class="menuTitle">Gespeicherte TXT-Dateien</div>
          <div id="menuList"></div>
        </div>
      </div>

      <button class="btn" type="button" onclick="toggleTheme()">ðŸŒ— Theme</button>
    </div>

    <div id="counter"></div>
  </div>

  <div class="center">
    <button class="arrow left" type="button" onclick="prev()">âžœ</button>

    <div class="card" id="card">
      <div class="inner">

        <!-- FRONT (EXAKT WIE BACK) -->
        <div class="face">
          <div class="header">
            <span id="frontTheme">Thema</span>
            <span class="pageNo" id="fNo">1</span>
          </div>
          <div class="vlabel"><span>Frage</span></div>

          <div class="content" id="frontContent">
            <div class="contentInner">
              <div class="answerWrap">
                <div class="solutionTitle" id="frontSolutionTitle"></div>
                <div id="frontHtml"></div>
              </div>
            </div>
          </div>
        </div>

        <!-- BACK -->
        <div class="face back">
          <div class="header">
            <span id="backTheme">Antwort</span>
            <span class="pageNo" id="bNo">1</span>
          </div>
          <div class="vlabel"><span>Antwort</span></div>

          <div class="content" id="backContent">
            <div class="contentInner">
              <div class="answerWrap">
                <div class="solutionTitle" id="solutionTitle"></div>
                <div id="backHtml"></div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <button class="arrow right" type="button" onclick="next()">âžœ</button>
  </div>
</div>

<script>
/* ===== THEME ===== */
function toggleTheme(){
  const r=document.documentElement;
  const t=r.getAttribute("data-theme")==="dark"?"":"dark";
  r.setAttribute("data-theme",t);
  localStorage.setItem("theme",t);
}
const savedTheme=localStorage.getItem("theme");
if(savedTheme) document.documentElement.setAttribute("data-theme",savedTheme);

/* ===== ELEMENTS ===== */
const fileInput=document.getElementById("fileInput");
const fileBtn=document.getElementById("fileBtn");
const activeFileName=document.getElementById("activeFileName");
const menu=document.getElementById("menu");
const menuList=document.getElementById("menuList");

const frontHtml=document.getElementById("frontHtml");
const backHtml=document.getElementById("backHtml");
const frontContent=document.getElementById("frontContent");
const backContent=document.getElementById("backContent");

const frontSolutionTitle=document.getElementById("frontSolutionTitle");
const solutionTitle=document.getElementById("solutionTitle");

const fNo=document.getElementById("fNo");
const bNo=document.getElementById("bNo");
const counter=document.getElementById("counter");
const card=document.getElementById("card");

const frontTheme=document.getElementById("frontTheme");
const backTheme=document.getElementById("backTheme");

/* ===== TXT STORAGE ===== */
const pre="flash_";
let cards=[];
let i=0;
let activeKey="";

function listKeys(){
  return Object.keys(localStorage)
    .filter(k=>k.startsWith(pre))
    .sort((a,b)=>a.localeCompare(b));
}

/* ===== IndexedDB per-TXT images ===== */
const DB_NAME = "karteikarten_db_v1";
const DB_VER  = 1;
const STORE_IMAGES = "images";

let dbPromise = null;
let imageUrls = new Map();

function openDB(){
  if(dbPromise) return dbPromise;
  dbPromise = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = ()=>{
      const db = req.result;
      if(!db.objectStoreNames.contains(STORE_IMAGES)){
        const store = db.createObjectStore(STORE_IMAGES, { keyPath: "id" });
        store.createIndex("byTxt", "txtKey", { unique:false });
      }
    };
    req.onsuccess = ()=>resolve(req.result);
    req.onerror = ()=>reject(req.error);
  });
  return dbPromise;
}
function makeImageId(txtKey, nameKey){
  return `${txtKey}|||${nameKey}`;
}
async function countImagesForTxt(txtKey){
  const db = await openDB();
  return await new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE_IMAGES, "readonly");
    const idx = tx.objectStore(STORE_IMAGES).index("byTxt");
    const req = idx.openCursor(IDBKeyRange.only(txtKey));
    let count=0;
    req.onsuccess = (e)=>{
      const cur = e.target.result;
      if(cur){ count++; cur.continue(); }
      else resolve(count);
    };
    req.onerror = ()=>reject(req.error);
  });
}
async function loadImagesForTxt(txtKey){
  for(const url of imageUrls.values()){
    try{ URL.revokeObjectURL(url); }catch{}
  }
  imageUrls = new Map();
  if(!txtKey) return;

  const db = await openDB();
  await new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE_IMAGES, "readonly");
    const store = tx.objectStore(STORE_IMAGES);
    const idx = store.index("byTxt");
    const req = idx.openCursor(IDBKeyRange.only(txtKey));
    req.onsuccess = (e)=>{
      const cur = e.target.result;
      if(cur){
        const v = cur.value;
        imageUrls.set(v.nameKey, URL.createObjectURL(v.blob));
        cur.continue();
      }else resolve();
    };
    req.onerror = ()=>reject(req.error);
  });
}
async function saveImagesForTxt(txtKey, files){
  const db = await openDB();
  await new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE_IMAGES, "readwrite");
    const store = tx.objectStore(STORE_IMAGES);

    let pending=0, done=0;
    const finish=()=>{ done++; if(done>=pending) resolve(); };

    for(const f of files){
      if(!f.type || !f.type.startsWith("image/")) continue;

      const base = (f.name || "").replace(/\.[^/.]+$/, "");
      const nameKey = base.trim().toLowerCase();
      if(!nameKey) continue;

      pending++;
      const rec = { id: makeImageId(txtKey, nameKey), txtKey, nameKey, blob: f };
      const req = store.put(rec);
      req.onsuccess = finish;
      req.onerror = ()=>reject(req.error);
    }
    if(pending===0) resolve();
  });
}
async function deleteAllImagesForTxt(txtKey){
  const db = await openDB();
  await new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE_IMAGES, "readwrite");
    const store = tx.objectStore(STORE_IMAGES);
    const idx = store.index("byTxt");
    const req = idx.openCursor(IDBKeyRange.only(txtKey));
    req.onsuccess = (e)=>{
      const cur = e.target.result;
      if(cur){ store.delete(cur.primaryKey); cur.continue(); }
      else resolve();
    };
    req.onerror = ()=>reject(req.error);
  });
}

/* ===== content helpers ===== */
function escapeHtml(s){
  return (s??"")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");
}
function injectImagesIntoText(raw){
  raw = (raw ?? "");
  if(!raw.trim()) return "â€”";

  let safe = escapeHtml(raw).replace(/\n/g,"<br>");

  safe = safe.replace(/#([^#<]+)#/g, (full, name)=>{
    const key = name.trim().toLowerCase();
    const url = imageUrls.get(key);
    if(!url) return "";
    return `<div class="inlineImgBox"><img class="inlineImg" src="${url}" alt=""></div>`;
  });

  return safe;
}

/* ===== parser ===== */
function parse(txt){
  txt = txt.replace(/\uFEFF/g,"").replace(/[\u200B-\u200D\u2060]/g,"");
  const lines = txt.replace(/\r/g,"").split("\n").map(x=>x.trimEnd());
  const cards=[];
  let c=null, last=null;

  const KNOWN = new Set([
    "frage","schwierigkeit","thema","text",
    "loesungs-titel","loesungstitel","loesungs titel",
    "loesung","losung"
  ]);

  function startCard(nr){
    if(c) cards.push(c);
    c={ nr:(nr||"").trim(), thema:"Thema", schwierigkeit:0, text:"", loesungstitel:"", loesung:"" };
    last=null;
  }
  function normKey(k){
    return k.trim()
      .replace(/[\u2010\u2011\u2012\u2013\u2014\u2212\uFE58\uFE63\uFF0D]/g, "-")
      .toLowerCase()
      .replace(/Ã¤/g,"ae").replace(/Ã¶/g,"oe").replace(/Ã¼/g,"ue")
      .replace(/ÃŸ/g,"ss")
      .replace(/\s+/g," ")
      .replace(/[^a-z0-9 \-]/g,"")
      .trim();
  }
  function appendToLast(line){
    if(!c || !last) return;
    c[last] += (c[last] ? "\n" : "") + line;
  }

  for(let idx=0; idx<lines.length; idx++){
    let line = lines[idx].trimEnd();

    if(!line){
      if(c && last) c[last] += "\n";
      continue;
    }

    const m = line.match(/^([^:]+):\s*(.*)$/);
    if(m){
      const key = normKey(m[1]);
      let val = (m[2] || "");

      if(c && last && !KNOWN.has(key)){
        appendToLast(line);
        continue;
      }

      if(val.trim()==="" && idx+1 < lines.length){
        const nextLine = (lines[idx+1]||"").trim();
        if(nextLine && !nextLine.match(/^([^:]+):\s*(.*)$/)){
          val = nextLine;
          idx++;
        }
      }

      if(key==="frage"){ startCard(val); continue; }
      if(!c) continue;

      if(key==="schwierigkeit"){ c.schwierigkeit = parseInt(val,10) || 0; last=null; continue; }
      if(key==="thema"){ c.thema = val.trim() || "Thema"; last=null; continue; }
      if(key==="text"){ c.text = val; last="text"; continue; }

      if(key==="loesungs-titel" || key==="loesungstitel" || key==="loesungs titel"){
        c.loesungstitel = val; last="loesungstitel"; continue;
      }

      if(key==="loesung" || key==="losung"){
        c.loesung = val; last="loesung"; continue;
      }

      last=null;
    }else{
      appendToLast(line);
    }
  }
  if(c) cards.push(c);
  return cards;
}

/* ===== render ===== */
async function render(){
  if(!cards.length){
    frontHtml.innerHTML = `<div class="answerText">TXT hochladenâ€¦</div>`;
    backHtml.innerHTML  = `<div class="answerText">â€”</div>`;

    frontSolutionTitle.textContent="";
    frontSolutionTitle.style.display="none";

    solutionTitle.textContent="";
    solutionTitle.style.display="none";

    counter.textContent="";
    frontTheme.textContent="Thema";
    backTheme.textContent="Antwort";
    fNo.textContent="1";
    bNo.textContent="1";
    return;
  }

  const c=cards[i];
  const nr=(c.nr || (i+1)).toString().trim();

  frontTheme.textContent=c.thema || "Thema";
  backTheme.textContent=c.thema || "Antwort";

  /* FRONT: exakt wie BACK */
  frontSolutionTitle.textContent="";
  frontSolutionTitle.style.display="none";

  frontHtml.innerHTML = `<div class="answerText">${injectImagesIntoText(c.text)}</div>`;

  /* BACK */
  const st=(c.loesungstitel||"").trim();
  solutionTitle.textContent=st;
  solutionTitle.style.display = st ? "block" : "none";

  backHtml.innerHTML = `<div class="answerText">${injectImagesIntoText(c.loesung)}</div>`;

  fNo.textContent=bNo.textContent=nr;
  counter.textContent=`Karte ${i+1} / ${cards.length}`;

  frontContent.scrollTop = 0;
  backContent.scrollTop  = 0;
  card.classList.remove("flipped");
}

/* ===== nav ===== */
function next(){ if(i<cards.length-1){i++; render();} }
function prev(){ if(i>0){i--; render();} }
card.onclick=()=>card.classList.toggle("flipped");
document.onkeydown=e=>{
  if(e.key==="ArrowRight") next();
  if(e.key==="ArrowLeft") prev();
  if(e.key===" ") card.classList.toggle("flipped");
};

/* ===== menu open/close ===== */
function openMenu(){ refreshMenu(); menu.classList.add("open"); }
function closeMenu(){ menu.classList.remove("open"); }
fileBtn.onclick=(e)=>{
  e.stopPropagation();
  menu.classList.contains("open") ? closeMenu() : openMenu();
};
function outsideClose(e){
  if(!menu.contains(e.target) && !fileBtn.contains(e.target)) closeMenu();
}
document.addEventListener("click", outsideClose);
document.addEventListener("touchstart", outsideClose, {passive:true});

/* ===== load txt ===== */
async function loadFromKey(k){
  const txt=localStorage.getItem(k);
  if(!txt) return;

  activeKey=k;
  activeFileName.textContent=k.replace(pre,"");

  await loadImagesForTxt(activeKey);
  cards=parse(txt);
  i=0;
  await render();
}

/* ===== upload txt ===== */
fileInput.onchange=()=>{
  const files=[...fileInput.files];
  if(!files.length) return;

  files.forEach((f,idx)=>{
    const r=new FileReader();
    r.onload=async ()=>{
      localStorage.setItem(pre+f.name,r.result);
      if(idx===0) await loadFromKey(pre+f.name);
      refreshMenu();
    };
    r.readAsText(f,"utf-8");
  });

  fileInput.value="";
};

/* ===== delete txt + images ===== */
async function deleteTxt(txtKey){
  const name = txtKey.replace(pre,"");
  if(!confirm(`"${name}" wirklich lÃ¶schen? (inkl. Bilder)`)) return;

  localStorage.removeItem(txtKey);
  await (async()=>{ await deleteAllImagesForTxt(txtKey); })();

  if(activeKey===txtKey){
    activeKey="";
    cards=[];
    i=0;
    activeFileName.textContent="TXT wÃ¤hlenâ€¦";
    await loadImagesForTxt("");
    await render();
  }
  refreshMenu();
}

/* ===== MENU BUILD ===== */
async function refreshMenu(){
  menuList.innerHTML="";
  const keys=listKeys();

  if(!keys.length){
    const empty=document.createElement("div");
    empty.style.padding="10px";
    empty.style.opacity=".65";
    empty.style.fontWeight="900";
    empty.textContent="Keine TXT gespeichert.";
    menuList.appendChild(empty);
    return;
  }

  for(const k of keys){
    const name=k.replace(pre,"");
    const row=document.createElement("div");
    row.className="menuItem";

    const left=document.createElement("div");
    left.className="menuItemName";
    left.textContent=name;

    const actions=document.createElement("div");
    actions.className="menuActions";

    const count = await countImagesForTxt(k);
    const badge=document.createElement("div");
    badge.className="smallBadge";
    badge.textContent=`ðŸ–¼ ${count}`;

    const uploadLabel=document.createElement("label");
    uploadLabel.className="actionBtn pickImg";
    uploadLabel.title="Bilder hinzufÃ¼gen";
    uploadLabel.textContent="ðŸ–¼";

    const imgInput=document.createElement("input");
    imgInput.className="imgRowInput";
    imgInput.type="file";
    imgInput.accept="image/*";
    imgInput.multiple=true;

    imgInput.onchange=async ()=>{
      const files=[...imgInput.files];
      if(!files.length) return;

      await saveImagesForTxt(k, files);

      if(activeKey===k){
        await loadImagesForTxt(activeKey);
        await render();
      }
      refreshMenu();
      imgInput.value="";
    };

    uploadLabel.appendChild(imgInput);

    badge.addEventListener("click",(ev)=>ev.stopPropagation());
    badge.addEventListener("touchstart",(ev)=>ev.stopPropagation(),{passive:true});
    uploadLabel.addEventListener("click",(ev)=>ev.stopPropagation());
    uploadLabel.addEventListener("touchstart",(ev)=>ev.stopPropagation(),{passive:true});

    const trash=document.createElement("button");
    trash.className="actionBtn";
    trash.type="button";
    trash.title="TXT lÃ¶schen";
    trash.textContent="ðŸ—‘";
    trash.onclick=async (ev)=>{
      ev.preventDefault(); ev.stopPropagation();
      await deleteTxt(k);
    };
    trash.addEventListener("touchstart", async (ev)=>{
      ev.preventDefault(); ev.stopPropagation();
      await deleteTxt(k);
    },{passive:false});

    actions.appendChild(badge);
    actions.appendChild(uploadLabel);
    actions.appendChild(trash);

    row.onclick=async ()=>{
      await loadFromKey(k);
      closeMenu();
    };

    row.appendChild(left);
    row.appendChild(actions);
    menuList.appendChild(row);
  }
}

/* INIT */
(async ()=>{
  await openDB();
  await render();
  await refreshMenu();
})();
</script>
</body>
</html>
