<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Karteikarten</title>
  <style>
    :root{
      --bg:#f5f6f8;
      --panel:#ffffff;
      --text:#0e1116;
      --muted:#6b7280;
      --border:rgba(16,24,40,.12);
      --shadow: 0 18px 60px rgba(0,0,0,.12);
      --accent:#2f6fed;
      --accent2:#16a34a;
      --danger:#ef4444;

      --cardW:14cm;
      --cardH:10cm;
      --headerH:44px;
      --sideW:46px;
      --pad:18px;
      --dot:10px;

      --imgMaxH:260px;
      --arrowSize:56px;
    }
    [data-theme="dark"]{
      --bg:#000000;
      --panel:#0b0f15;
      --text:#ffffff;
      --muted:#a2aab8;
      --border:rgba(255,255,255,.12);
      --shadow: 0 22px 70px rgba(0,0,0,.55);
      --accent:#7aa2ff;
      --accent2:#22c55e;
      --danger:#fb7185;
      --panel2:#0a0a0a;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 700px at 20% 10%, rgba(47,111,237,.12), transparent 50%),
                  radial-gradient(900px 600px at 80% 10%, rgba(34,197,94,.10), transparent 60%),
                  var(--bg);
      color:var(--text);
      overflow-x:hidden;
    }

    /* Top bar */
    .topbar{
      position:sticky;
      top:0;
      z-index:20;
      padding:12px 14px;
      background: color-mix(in srgb, var(--bg) 88%, transparent);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border-bottom: 1px solid var(--border);
    }
    .topbar-inner{
      max-width: 1160px;
      margin:0 auto;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .brand{
      display:flex;align-items:center;gap:10px;
      font-weight:800;
      letter-spacing:.2px;
      margin-right:auto;
      user-select:none;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:14px;
      background: color-mix(in srgb, var(--panel) 92%, transparent);
      box-shadow: 0 10px 24px rgba(0,0,0,.08);
      min-height:44px;
    }
    .select{
      appearance:none;
      border:none;
      outline:none;
      background:transparent;
      color:var(--text);
      font-weight:650;
      font-size:14px;
      max-width: 320px;
      width: min(320px, 56vw);
    }
    .select-wrap{
      display:flex;
      align-items:center;
      gap:8px;
      width:100%;
    }
    .caret{
      width:10px;height:10px;
      border-right:2px solid var(--muted);
      border-bottom:2px solid var(--muted);
      transform: rotate(45deg);
      margin-left:auto;
      opacity:.9;
    }

    .btn{
      border:1px solid var(--border);
      background: color-mix(in srgb, var(--panel) 92%, transparent);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:750;
      font-size:14px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:8px;
      min-height:44px;
      transition: transform .08s ease, box-shadow .18s ease, border-color .18s ease, background .18s ease;
      box-shadow: 0 10px 24px rgba(0,0,0,.08);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:hover{transform: translateY(-1px); border-color: color-mix(in srgb, var(--accent) 50%, var(--border));}
    .btn:active{transform: translateY(0px) scale(.99);}
    .btn.primary{
      background: linear-gradient(180deg, color-mix(in srgb, var(--accent) 22%, var(--panel)) 0%, color-mix(in srgb, var(--accent) 14%, var(--panel)) 100%);
      border-color: color-mix(in srgb, var(--accent) 40%, var(--border));
    }
    .btn.danger{
      background: linear-gradient(180deg, color-mix(in srgb, var(--danger) 14%, var(--panel)) 0%, color-mix(in srgb, var(--danger) 10%, var(--panel)) 100%);
      border-color: color-mix(in srgb, var(--danger) 40%, var(--border));
    }
    .btn.icon{
      width:44px; padding:10px;
      font-size:18px; font-weight:900;
    }
    .btn.small{
      min-height:40px;
      padding:9px 11px;
      border-radius:12px;
    }
    .hint{
      font-size:12px;
      color:var(--muted);
      font-weight:600;
    }

    /* Main layout */
    .wrap{
      max-width: 1160px;
      margin: 18px auto 60px;
      padding: 0 14px;
    }

    .stage{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:18px;
      min-height: calc(100vh - 140px);
      padding: 12px 0 40px;
    }

    .arrow{
      width: clamp(44px, 8vw, 88px);
      height: clamp(72px, 18vw, 140px);
      border-radius: 22px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel) 92%, transparent);
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .08s ease, border-color .18s ease, background .18s ease;
    }
    .arrow:hover{transform: translateY(-1px); border-color: color-mix(in srgb, var(--accent) 55%, var(--border));}
    .arrow:active{transform: translateY(0px) scale(.99);}
    .arrow span{
      font-size: var(--arrowSize);
      line-height:1;
      font-weight:900;
      color: var(--text);
      opacity:.92;
      transform: translateX(2px);
    }
    .arrow.left span{
      transform: scaleX(-1) translateX(2px);
    }
    .arrow[aria-disabled="true"]{
      opacity:.35;
      cursor:not-allowed;
      filter: grayscale(.3);
    }

    /* Card */
    .card-shell{
      width: var(--cardW);
      height: var(--cardH);
      max-width: 92vw;
      max-height: 66vh;
      position:relative;
      perspective: 1200px;
    }

    .card{
      width:100%;
      height:100%;
      position:relative;
      transform-style: preserve-3d;
      transition: transform .55s cubic-bezier(.2,.9,.2,1);
      border-radius: 22px;
      box-shadow: var(--shadow);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .card.flipped{ transform: rotateY(180deg); }

    .face{
      position:absolute;
      inset:0;
      background: linear-gradient(180deg, color-mix(in srgb, var(--panel) 96%, transparent) 0%, color-mix(in srgb, var(--panel) 92%, transparent) 100%);
      border: 1px solid var(--border);
      border-radius: 22px;
      overflow:hidden;
      backface-visibility: hidden;
      display:flex;
      flex-direction:column;
    }
    .face.back{ transform: rotateY(180deg); }

    .header{
      height: var(--headerH);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 0 14px;
      font-weight:900;
      letter-spacing:.2px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg,
        color-mix(in srgb, var(--accent) 12%, var(--panel)) 0%,
        color-mix(in srgb, var(--accent) 6%, var(--panel)) 100%
      );
      color: var(--text);
      text-align:center;
      user-select:none;
    }
    .grid{
      flex:1;
      display:grid;
      grid-template-columns: var(--sideW) 1fr;
      min-height:0; /* allow inner scrolling */
    }
    .side{
      border-right: 1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 12px 6px;
      user-select:none;
      background: color-mix(in srgb, var(--panel) 92%, transparent);
    }
    .side .vertical{
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      font-weight:900;
      letter-spacing:.18em;
      color: color-mix(in srgb, var(--muted) 85%, var(--text));
      font-size: 12px;
    }

    .content{
      padding: var(--pad);
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .scroll{
      flex:1;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      min-height:0;
      padding-right: 6px;
      overscroll-behavior: contain;
    }
    .scroll::-webkit-scrollbar{width:10px}
    .scroll::-webkit-scrollbar-thumb{
      background: color-mix(in srgb, var(--muted) 35%, transparent);
      border-radius: 999px;
      border: 2px solid transparent;
      background-clip: padding-box;
    }

    .text{
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      justify-content:flex-start;
      text-align:center;
      line-height:1.35;
      font-weight:750;
      font-size: clamp(16px, 2.1vw, 22px);
      white-space: pre-wrap;
      word-break: break-word;
      overflow-wrap:anywhere;
    }
    .subtitle{
      font-size: clamp(14px, 1.8vw, 18px);
      font-weight:900;
      color: color-mix(in srgb, var(--text) 90%, var(--muted));
      margin-top:2px;
    }

    .inline-img{
      width:100%;
      max-width: 100%;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel) 92%, transparent);
      box-shadow: 0 10px 28px rgba(0,0,0,.10);
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 10px;
    }
    .inline-img img{
      width: 100%;
      height: auto;
      max-height: var(--imgMaxH);
      object-fit: contain;
      display:block;
    }

    .dots{
      display:flex;
      gap:10px;
      justify-content:center;
      align-items:center;
      padding-top: 14px;
      user-select:none;
    }
    .dot{
      width: var(--dot);
      height: var(--dot);
      border-radius: 999px;
      border: 2px solid color-mix(in srgb, var(--muted) 55%, var(--text));
      background: transparent;
      opacity:.9;
    }
    .dot.filled{
      background: color-mix(in srgb, var(--accent) 65%, var(--text));
      border-color: color-mix(in srgb, var(--accent) 65%, var(--text));
    }

    .statusbar{
      margin-top: 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:12px;
      color:var(--muted);
      font-weight:750;
      font-size:13px;
      user-select:none;
    }
    .badge{
      padding:6px 10px;
      border-radius:999px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel) 92%, transparent);
    }

    .empty{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 24px;
      color: var(--muted);
      font-weight:700;
    }
    .empty .big{
      font-size: 44px;
      line-height:1;
      opacity:.9;
    }

    /* Mobile tweaks */
    @media (max-width: 720px){
      :root{
        --headerH: 40px;
        --sideW: 42px;
        --pad: 14px;
        --imgMaxH: 180px;
        --arrowSize: 50px;
      }
      .topbar-inner{gap:8px}
      .brand{margin-right:0; width:100%; justify-content:space-between}
      .pill{flex:1}
      .select{max-width: unset; width:100%}
      .stage{gap:10px; min-height: calc(100vh - 200px);}
      .arrow{
        width: 16vw;
        height: min(22vh, 160px);
        border-radius: 20px;
      }
      .card-shell{
        max-height: 64vh;
      }
    }

    @media (prefers-reduced-motion: reduce){
      .card{transition:none}
      .btn,.arrow{transition:none}
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div style="display:flex;align-items:center;gap:10px;">
          <div style="width:12px;height:12px;border-radius:999px;background:var(--accent);box-shadow:0 0 0 6px color-mix(in srgb, var(--accent) 14%, transparent);"></div>
          <div>Karteikarten</div>
        </div>
        <button id="themeBtn" class="btn icon" title="Theme wechseln" aria-label="Theme wechseln">ðŸŒ™</button>
      </div>

      <div class="pill" style="flex:1;min-width:min(520px,100%);">
        <div class="select-wrap" style="width:100%;">
          <select id="deckSelect" class="select" title="TXT auswÃ¤hlen"></select>
          <div class="caret" aria-hidden="true"></div>
        </div>
      </div>

      <button id="uploadTxtBtn" class="btn primary" title="TXT hochladen">TXT hochladen</button>
      <button id="uploadImgBtn" class="btn small" title="Bilder hochladen" aria-label="Bilder hochladen">ðŸ–¼</button>
      <button id="deleteDeckBtn" class="btn danger small" title="TXT lÃ¶schen" aria-label="TXT lÃ¶schen">ðŸ—‘</button>

      <input id="txtInput" type="file" accept=".txt,text/plain" multiple hidden />
      <input id="imgInput" type="file" accept="image/*" multiple hidden />
    </div>
  </div>

  <div class="wrap">
    <div class="stage">
      <div id="prevBtn" class="arrow left" role="button" aria-label="Vorherige Karte" tabindex="0">
        <span>âžœ</span>
      </div>

      <div class="card-shell">
        <div id="card" class="card" role="button" aria-label="Karte umdrehen" tabindex="0">
          <div class="face front">
            <div class="header" id="topicFront">â€“</div>
            <div class="grid">
              <div class="side"><div class="vertical">FRAGE</div></div>
              <div class="content">
                <div class="scroll">
                  <div class="text" id="frontText"></div>
                </div>
                <div class="dots" id="dotsFront" aria-label="Schwierigkeit"></div>
              </div>
            </div>
          </div>

          <div class="face back">
            <div class="header" id="topicBack">â€“</div>
            <div class="grid">
              <div class="side"><div class="vertical">ANTWORT</div></div>
              <div class="content">
                <div class="scroll">
                  <div class="text" id="backText"></div>
                </div>
                <div class="dots" id="dotsBack" aria-label="Schwierigkeit"></div>
              </div>
            </div>
          </div>
        </div>

        <div id="emptyState" class="empty" style="display:none;">
          <div class="big">ðŸ“„</div>
          <div>Keine TXT geladen.</div>
          <div class="hint">Lade eine oder mehrere <b>.txt</b>-Dateien hoch, dann kannst du durch die Karten navigieren.</div>
        </div>
      </div>

      <div id="nextBtn" class="arrow" role="button" aria-label="NÃ¤chste Karte" tabindex="0">
        <span>âžœ</span>
      </div>
    </div>

    <div class="statusbar">
      <div class="badge" id="countBadge">0 / 0</div>
      <div class="badge" id="deckBadge">â€“</div>
      <div class="badge" id="imgBadge">ðŸ–¼ 0</div>
      <div class="hint" id="hint">Klick auf Karte = Flip â€¢ Pfeile = Navigation</div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // -----------------------------
  // Helpers
  // -----------------------------
  const $ = (sel, el=document) => el.querySelector(sel);
  const $$ = (sel, el=document) => Array.from(el.querySelectorAll(sel));
  const uid = () => Math.random().toString(36).slice(2, 10) + "-" + Date.now().toString(36);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
  const stripExt = (name) => name.replace(/\.[^/.]+$/,"");
  const normalizeKey = (s) => (s || "").toString().trim().toLowerCase();
  const safeText = (s) => (s ?? "").toString();

  function setAriaDisabled(el, disabled){
    el.setAttribute("aria-disabled", disabled ? "true" : "false");
  }

  // -----------------------------
  // Theme
  // -----------------------------
  const themeBtn = $("#themeBtn");
  function getTheme(){
    return localStorage.getItem("flash_theme") || (matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
  }
  function setTheme(t){
    document.documentElement.setAttribute("data-theme", t);
    localStorage.setItem("flash_theme", t);
    themeBtn.textContent = (t === "dark") ? "â˜€ï¸" : "ðŸŒ™";
    themeBtn.title = (t === "dark") ? "Light Mode" : "Dark Mode";
  }
  setTheme(getTheme());
  themeBtn.addEventListener("click", () => setTheme(getTheme() === "dark" ? "light" : "dark"));

  // -----------------------------
  // IndexedDB for images
  // -----------------------------
  const DB_NAME = "flashcards_images_v1";
  const STORE = "images";
  let db = null;

  function openDB(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = (e) => {
        const d = e.target.result;
        if (!d.objectStoreNames.contains(STORE)) {
          d.createObjectStore(STORE, { keyPath: "key" }); // key = deckId|nameLower
        }
      };
      req.onsuccess = () => { db = req.result; resolve(db); };
      req.onerror = () => reject(req.error);
    });
  }

  function withStore(mode, fn){
    return new Promise((resolve, reject) => {
      if(!db){ reject(new Error("DB not open")); return; }
      const tx = db.transaction(STORE, mode);
      const st = tx.objectStore(STORE);
      let out;
      try { out = fn(st, tx); } catch(err){ reject(err); return; }
      tx.oncomplete = () => resolve(out);
      tx.onerror = () => reject(tx.error);
      tx.onabort = () => reject(tx.error);
    });
  }

  function imgKey(deckId, nameLower){
    return `${deckId}|${nameLower}`;
  }

  async function putImage(deckId, file){
    const nameLower = normalizeKey(stripExt(file.name));
    if(!nameLower) return;
    const blob = file.slice(0, file.size, file.type || "application/octet-stream");
    await withStore("readwrite", (st) => st.put({ key: imgKey(deckId, nameLower), deckId, nameLower, blob, type: file.type || blob.type || "" }));
  }

  async function getImageBlob(deckId, nameLower){
    const key = imgKey(deckId, nameLower);
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readonly");
      const st = tx.objectStore(STORE);
      const req = st.get(key);
      req.onsuccess = () => resolve(req.result ? req.result.blob : null);
      req.onerror = () => reject(req.error);
    });
  }

  async function countImages(deckId){
    // Iterate (prefix scan) because key includes deckId.
    const prefix = `${deckId}|`;
    return await new Promise((resolve, reject) => {
      let count = 0;
      const tx = db.transaction(STORE, "readonly");
      const st = tx.objectStore(STORE);
      const req = st.openCursor();
      req.onsuccess = (e) => {
        const cur = e.target.result;
        if(!cur){ resolve(count); return; }
        if(cur.key && String(cur.key).startsWith(prefix)) count++;
        cur.continue();
      };
      req.onerror = () => reject(req.error);
    });
  }

  async function deleteDeckImages(deckId){
    const prefix = `${deckId}|`;
    return await new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      const st = tx.objectStore(STORE);
      const req = st.openCursor();
      req.onsuccess = (e) => {
        const cur = e.target.result;
        if(!cur){ resolve(true); return; }
        if(cur.key && String(cur.key).startsWith(prefix)){
          st.delete(cur.key);
        }
        cur.continue();
      };
      req.onerror = () => reject(req.error);
    });
  }

  // Cache object URLs for current render to avoid leaks
  let objectUrlCache = new Map(); // nameLower -> url
  function revokeAllObjectUrls(){
    for(const url of objectUrlCache.values()){
      try{ URL.revokeObjectURL(url); }catch{}
    }
    objectUrlCache.clear();
  }

  // -----------------------------
  // Local storage for decks (TXT)
  // -----------------------------
  const LS_KEY = "flash_decks_v1";
  function loadDecks(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      const decks = raw ? JSON.parse(raw) : [];
      return Array.isArray(decks) ? decks : [];
    }catch{
      return [];
    }
  }
  function saveDecks(decks){
    localStorage.setItem(LS_KEY, JSON.stringify(decks));
  }

  function upsertDeck(deck){
    const decks = loadDecks();
    const idx = decks.findIndex(d => d.id === deck.id);
    if(idx >= 0) decks[idx] = deck;
    else decks.unshift(deck);
    saveDecks(decks);
  }

  function deleteDeck(deckId){
    const decks = loadDecks().filter(d => d.id !== deckId);
    saveDecks(decks);
  }

  // -----------------------------
  // Parser (robust)
  // -----------------------------
  const KEYWORDS = [
    "frage", "schwierigkeit", "thema", "text", "lÃ¶sungs-titel", "loesungs-titel", "lÃ¶sung", "loesung"
  ];

  function normalizeFieldName(line){
    const s = normalizeKey(line);
    // unify umlaut/variant spellings
    if(s.startsWith("loesungs-titel")) return "lÃ¶sungs-titel";
    if(s.startsWith("lÃ¶sungs-titel")) return "lÃ¶sungs-titel";
    if(s.startsWith("loesung")) return "lÃ¶sung";
    if(s.startsWith("lÃ¶sung")) return "lÃ¶sung";
    return s;
  }

  function isFieldLine(line){
    const t = normalizeKey(line);
    // Accept "Key:" or "Key :" etc.
    const m = t.match(/^([a-zÃ¤Ã¶Ã¼ÃŸ\- ]+)\s*:/i);
    if(!m) return null;
    const keyRaw = m[1].trim();
    const key = normalizeFieldName(keyRaw);
    // allow spaces in key
    const keyCompact = key.replace(/\s+/g, "");
    const allowed = KEYWORDS.map(k => k.replace(/\s+/g,""));
    if(!allowed.includes(keyCompact)) return null;
    return { key: keyCompact, raw: line };
  }

  function splitKeyValue(line){
    const idx = line.indexOf(":");
    if(idx === -1) return [line.trim(), ""];
    const k = line.slice(0, idx).trim();
    const v = line.slice(idx+1).trim();
    return [k, v];
  }

  function parseTxtToCards(txt){
    // Robust approach:
    // - scan line-by-line
    // - detect fields "Frage:", "Schwierigkeit:", "Thema:", "Text:", "LÃ¶sungs-Titel:", "LÃ¶sung:"
    // - value may be on same line or next non-empty line
    // - Text/LÃ¶sung are multi-line until next recognized field (or EOF)
    // - Multiple cards in a file; a new "Frage:" starts a new card (commits previous)
    const lines = safeText(txt).replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n");

    const cards = [];
    let cur = null;
    let mode = null; // "text" | "lÃ¶sung" | null
    let pendingKey = null; // for value in next line

    function newCard(){
      return {
        frage: "",
        schwierigkeit: 1,
        thema: "",
        text: "",
        loesungsTitel: "",
        loesung: ""
      };
    }
    function commit(){
      if(!cur) return;
      // If card is basically empty, skip
      const hasAny = [cur.frage, cur.thema, cur.text, cur.loesung, cur.loesungsTitel].some(v => safeText(v).trim().length>0);
      if(!hasAny) { cur = null; mode = null; pendingKey = null; return; }
      cur.schwierigkeit = clamp(parseInt(cur.schwierigkeit,10) || 1, 1, 3);
      cards.push(cur);
      cur = null;
      mode = null;
      pendingKey = null;
    }

    cur = newCard();

    for(let i=0;i<lines.length;i++){
      const rawLine = lines[i];
      const line = rawLine; // keep original for text content (preserve case)
      const trimmed = line.trim();

      // If we are waiting for a scalar value in the next line
      if(pendingKey){
        if(trimmed !== ""){
          applyScalar(pendingKey, trimmed);
          pendingKey = null;
          continue;
        } else {
          // keep waiting through blank lines for scalar fields
          continue;
        }
      }

      // Detect field header
      const fl = isFieldLine(line);
      if(fl){
        const [kRaw, vRaw] = splitKeyValue(line);
        const keyNorm = normalizeFieldName(kRaw).replace(/\s+/g,"");

        // Starting a new card when encountering "Frage:" and current card already has content
        if(keyNorm === "frage"){
          // If current card already has some content and we're seeing a new Frage, commit and start new
          const curHasAny = cur && [cur.frage, cur.thema, cur.text, cur.loesung, cur.loesungsTitel].some(v => safeText(v).trim().length>0);
          if(curHasAny) commit();
          if(!cur) cur = newCard();
        }

        // Set mode depending on key
        if(keyNorm === "text"){
          mode = "text";
          if(vRaw !== ""){
            // Start with same-line remainder
            cur.text = (cur.text ? cur.text + "\n" : "") + vRaw;
          }
          continue;
        }
        if(keyNorm === "lÃ¶sung" || keyNorm === "loesung"){
          mode = "lÃ¶sung";
          if(vRaw !== ""){
            cur.loesung = (cur.loesung ? cur.loesung + "\n" : "") + vRaw;
          }
          continue;
        }

        // Scalars end multiline capture mode
        mode = null;

        if(vRaw !== ""){
          applyScalar(keyNorm, vRaw);
        }else{
          // value might be next line
          pendingKey = keyNorm;
        }
        continue;
      }

      // Not a field header -> append to current multiline section if any
      if(mode === "text"){
        cur.text += (cur.text ? "\n" : "") + line;
      } else if(mode === "lÃ¶sung"){
        cur.loesung += (cur.loesung ? "\n" : "") + line;
      } else {
        // Ignore stray lines outside of sections, but if there is content and no mode,
        // we can attach it to text as a fallback (robustness).
        if(trimmed !== ""){
          // If nothing else is set, treat as part of text
          if(!cur.text.trim() && !cur.loesung.trim()){
            cur.text += (cur.text ? "\n" : "") + line;
          }
        }
      }
    }

    // Commit last card
    commit();

    // Post-clean: normalize fields
    for(const c of cards){
      c.frage = safeText(c.frage).trim();
      c.thema = safeText(c.thema).trim();
      c.text = safeText(c.text).trim();
      c.loesungsTitel = safeText(c.loesungsTitel).trim();
      c.loesung = safeText(c.loesung).trim();
      // If no explicit theme, keep empty
      // If no Frage, also ok (we still render)
    }

    return cards;

    function applyScalar(keyNorm, value){
      if(!cur) cur = newCard();
      const val = safeText(value).trim();
      if(keyNorm === "frage"){
        cur.frage = val;
      } else if(keyNorm === "schwierigkeit"){
        cur.schwierigkeit = val;
      } else if(keyNorm === "thema"){
        cur.thema = val;
      } else if(keyNorm === "lÃ¶sungs-titel" || keyNorm === "loesungs-titel"){
        cur.loesungsTitel = val;
      } else if(keyNorm === "lÃ¶sung" || keyNorm === "loesung"){
        // If someone wrote "LÃ¶sung:" but parser treated it as scalar (rare), switch to mode would be better,
        // but still handle as start content.
        cur.loesung = val;
      } else if(keyNorm === "text"){
        cur.text = val;
      }
    }
  }

  // -----------------------------
  // Marker replacement (#Name#) -> inline image
  // -----------------------------
  const MARKER_RE = /#([^#]+?)#/g;

  async function renderWithMarkers(deckId, raw){
    // Returns a DocumentFragment with text nodes + image blocks, removing markers that don't exist.
    // Marker match is case-insensitive and uses file name without extension.
    const frag = document.createDocumentFragment();
    const s = safeText(raw);

    let lastIdx = 0;
    let match;

    // We need to interleave text and images; for layout consistency, each image becomes a block.
    while((match = MARKER_RE.exec(s)) !== null){
      const start = match.index;
      const end = start + match[0].length;
      const name = normalizeKey(match[1]);
      // text before marker
      if(start > lastIdx){
        frag.appendChild(document.createTextNode(s.slice(lastIdx, start)));
      }

      if(name){
        let url = objectUrlCache.get(name);
        if(!url){
          const blob = await getImageBlob(deckId, name);
          if(blob){
            url = URL.createObjectURL(blob);
            objectUrlCache.set(name, url);
          } else {
            url = null;
          }
        }
        if(url){
          const wrap = document.createElement("div");
          wrap.className = "inline-img";
          const img = document.createElement("img");
          img.alt = name;
          img.src = url;
          img.loading = "lazy";
          wrap.appendChild(img);
          frag.appendChild(wrap);
        }
      }
      // if no image exists -> marker disappears (do nothing)
      lastIdx = end;
    }

    if(lastIdx < s.length){
      frag.appendChild(document.createTextNode(s.slice(lastIdx)));
    }

    return frag;
  }

  // -----------------------------
  // UI / App State
  // -----------------------------
  const deckSelect = $("#deckSelect");
  const uploadTxtBtn = $("#uploadTxtBtn");
  const uploadImgBtn = $("#uploadImgBtn");
  const deleteDeckBtn = $("#deleteDeckBtn");
  const txtInput = $("#txtInput");
  const imgInput = $("#imgInput");

  const cardEl = $("#card");
  const topicFront = $("#topicFront");
  const topicBack = $("#topicBack");
  const frontText = $("#frontText");
  const backText = $("#backText");
  const dotsFront = $("#dotsFront");
  const dotsBack = $("#dotsBack");

  const prevBtn = $("#prevBtn");
  const nextBtn = $("#nextBtn");
  const countBadge = $("#countBadge");
  const deckBadge = $("#deckBadge");
  const imgBadge = $("#imgBadge");
  const emptyState = $("#emptyState");

  let state = {
    decks: [],
    deckId: null,
    cards: [],
    idx: 0,
  };

  function currentDeck(){
    return state.decks.find(d => d.id === state.deckId) || null;
  }

  function setEmpty(isEmpty){
    cardEl.style.display = isEmpty ? "none" : "block";
    emptyState.style.display = isEmpty ? "flex" : "none";
    prevBtn.style.visibility = isEmpty ? "hidden" : "visible";
    nextBtn.style.visibility = isEmpty ? "hidden" : "visible";
  }

  function buildDots(el, difficulty){
    el.innerHTML = "";
    const d = clamp(parseInt(difficulty,10) || 1, 1, 3);
    for(let i=1;i<=3;i++){
      const dot = document.createElement("div");
      dot.className = "dot" + (i<=d ? " filled" : "");
      el.appendChild(dot);
    }
  }

  function setNavDisabled(){
    const total = state.cards.length;
    setAriaDisabled(prevBtn, total === 0 || state.idx <= 0);
    setAriaDisabled(nextBtn, total === 0 || state.idx >= total - 1);
  }

  function setBadges(){
    const total = state.cards.length;
    countBadge.textContent = total ? `${state.idx+1} / ${total}` : "0 / 0";
    const d = currentDeck();
    deckBadge.textContent = d ? d.name : "â€“";
  }

  async function updateImageBadge(){
    const d = currentDeck();
    if(!d){ imgBadge.textContent = "ðŸ–¼ 0"; return; }
    const n = await countImages(d.id);
    imgBadge.textContent = `ðŸ–¼ ${n}`;
  }

  function resetScroll(){
    // Scroll both faces to top (same logic for question & answer)
    $$(".scroll", cardEl).forEach(sc => { sc.scrollTop = 0; });
  }

  async function renderCard(){
    revokeAllObjectUrls();
    const d = currentDeck();

    if(!d || state.cards.length === 0){
      setEmpty(true);
      setBadges();
      setNavDisabled();
      await updateImageBadge();
      return;
    }

    setEmpty(false);

    const c = state.cards[state.idx];
    const topic = c.thema || "â€“";
    topicFront.textContent = topic;
    topicBack.textContent = topic;

    // FRONT content (question)
    frontText.innerHTML = "";
    // if you want "Frage:" number visible, include it subtly
    // (but requirement doesn't demand it on card; keep clean)
    const fragFront = await renderWithMarkers(d.id, c.text || "");
    frontText.appendChild(fragFront);

    // BACK content (answer)
    backText.innerHTML = "";
    const container = document.createDocumentFragment();

    const title = (c.loesungsTitel || "").trim();
    if(title){
      const t = document.createElement("div");
      t.className = "subtitle";
      t.textContent = title;
      container.appendChild(t);
    }
    const fragBack = await renderWithMarkers(d.id, c.loesung || "");
    container.appendChild(fragBack);
    backText.appendChild(container);

    buildDots(dotsFront, c.schwierigkeit);
    buildDots(dotsBack, c.schwierigkeit);

    setBadges();
    setNavDisabled();
    resetScroll();
    await updateImageBadge();
  }

  function flip(){
    cardEl.classList.toggle("flipped");
    // Keep scrolling behavior identical: reset both sides to top on flip
    resetScroll();
  }

  function prev(){
    if(state.idx > 0){
      state.idx--;
      cardEl.classList.remove("flipped");
      renderCard();
    }
  }
  function next(){
    if(state.idx < state.cards.length - 1){
      state.idx++;
      cardEl.classList.remove("flipped");
      renderCard();
    }
  }

  // -----------------------------
  // Deck dropdown
  // -----------------------------
  function refreshDeckSelect(){
    state.decks = loadDecks();
    deckSelect.innerHTML = "";

    if(state.decks.length === 0){
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "Keine TXT gespeichert";
      deckSelect.appendChild(opt);
      deckSelect.disabled = true;
      state.deckId = null;
      state.cards = [];
      state.idx = 0;
      renderCard();
      return;
    }

    deckSelect.disabled = false;
    for(const d of state.decks){
      const opt = document.createElement("option");
      opt.value = d.id;
      opt.textContent = d.name;
      deckSelect.appendChild(opt);
    }

    // Keep selection if possible
    if(!state.deckId || !state.decks.some(d => d.id === state.deckId)){
      state.deckId = state.decks[0].id;
    }
    deckSelect.value = state.deckId;
  }

  function loadSelectedDeck(){
    const d = currentDeck();
    if(!d){
      state.cards = [];
      state.idx = 0;
      renderCard();
      return;
    }
    const cards = parseTxtToCards(d.text);
    state.cards = cards;
    state.idx = 0;
    renderCard();
  }

  deckSelect.addEventListener("change", () => {
    state.deckId = deckSelect.value || null;
    cardEl.classList.remove("flipped");
    loadSelectedDeck();
  });

  // -----------------------------
  // TXT upload
  // -----------------------------
  uploadTxtBtn.addEventListener("click", () => txtInput.click());
  txtInput.addEventListener("change", async (e) => {
    const files = Array.from(e.target.files || []);
    if(files.length === 0) return;

    for(const f of files){
      try{
        const text = await f.text();
        const deck = {
          id: uid(),
          name: f.name.replace(/\.txt$/i,""),
          text,
          createdAt: Date.now()
        };
        upsertDeck(deck);
      }catch(err){
        console.error("TXT read failed:", err);
      }
    }
    txtInput.value = "";
    refreshDeckSelect();
    loadSelectedDeck();
  });

  // -----------------------------
  // Images upload
  // -----------------------------
  uploadImgBtn.addEventListener("click", () => {
    const d = currentDeck();
    if(!d){
      alert("Bitte zuerst eine TXT auswÃ¤hlen oder hochladen.");
      return;
    }
    imgInput.click();
  });

  imgInput.addEventListener("change", async (e) => {
    const d = currentDeck();
    const files = Array.from(e.target.files || []);
    if(!d || files.length === 0) return;

    // Store each image under deckId + normalized nameLower (without extension)
    try{
      for(const file of files){
        await putImage(d.id, file);
      }
    }catch(err){
      console.error("Image store failed:", err);
      alert("Bilder konnten nicht gespeichert werden (IndexedDB).");
    }finally{
      imgInput.value = "";
      // Re-render to resolve markers immediately
      await renderCard();
    }
  });

  // -----------------------------
  // Delete deck
  // -----------------------------
  deleteDeckBtn.addEventListener("click", async () => {
    const d = currentDeck();
    if(!d) return;

    const ok = confirm(`TXT wirklich lÃ¶schen?\n\n${d.name}\n\n(inkl. aller zugehÃ¶rigen Bilder)`);
    if(!ok) return;

    try{
      deleteDeck(d.id);
      await deleteDeckImages(d.id);
    }catch(err){
      console.error("Delete failed:", err);
    }

    // refresh state
    cardEl.classList.remove("flipped");
    refreshDeckSelect();
    loadSelectedDeck();
  });

  // -----------------------------
  // Card interactions
  // -----------------------------
  cardEl.addEventListener("click", (e) => {
    // If user is scrolling, avoid accidental flip:
    // - ignore if click originated from scrollbar drag etc. (basic)
    // - still allow tap anywhere else
    flip();
  });

  // Keyboard support
  function onKeyActivate(el, handler){
    el.addEventListener("keydown", (e) => {
      if(e.key === "Enter" || e.key === " "){
        e.preventDefault();
        handler();
      }
      if(e.key === "ArrowLeft") prev();
      if(e.key === "ArrowRight") next();
    });
  }
  onKeyActivate(prevBtn, prev);
  onKeyActivate(nextBtn, next);
  onKeyActivate(cardEl, flip);

  prevBtn.addEventListener("click", () => {
    if(prevBtn.getAttribute("aria-disabled")==="true") return;
    prev();
  });
  nextBtn.addEventListener("click", () => {
    if(nextBtn.getAttribute("aria-disabled")==="true") return;
    next();
  });

  // Optional: swipe (nice on mobile) â€” does not interfere with inner scrolling
  let touch = {x:0,y:0,t:0,active:false};
  const swipeThreshold = 50;
  const swipeTime = 700;
  document.addEventListener("touchstart", (e) => {
    if(e.touches.length !== 1) return;
    const target = e.target;
    // If touching inside scroll area, let scroll happen (still allow horizontal swipe if strong)
    touch = {x: e.touches[0].clientX, y: e.touches[0].clientY, t: Date.now(), active:true, target};
  }, {passive:true});

  document.addEventListener("touchend", (e) => {
    if(!touch.active) return;
    const dt = Date.now() - touch.t;
    if(dt > swipeTime){ touch.active=false; return; }
    const changed = e.changedTouches && e.changedTouches[0];
    if(!changed){ touch.active=false; return; }
    const dx = changed.clientX - touch.x;
    const dy = changed.clientY - touch.y;

    // Only horizontal swipe, avoid vertical scroll gestures
    if(Math.abs(dx) > swipeThreshold && Math.abs(dx) > Math.abs(dy) * 1.2){
      if(dx > 0) prev();
      else next();
    }
    touch.active=false;
  }, {passive:true});

  // -----------------------------
  // Init
  // -----------------------------
  (async function init(){
    try{ await openDB(); }catch(err){
      console.error("IndexedDB open failed:", err);
      alert("IndexedDB ist nicht verfÃ¼gbar. Bilder kÃ¶nnen nicht gespeichert werden.");
    }
    refreshDeckSelect();
    loadSelectedDeck();
  })();

})();
</script>
</body>
</html>
