<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Karteikarten</title>
  <style>
    :root{
      --bg: #f6f7fb;
      --panel: rgba(255,255,255,0.75);
      --panel-solid: #ffffff;
      --text: #0b0f1a;
      --muted: rgba(11,15,26,0.6);
      --stroke: rgba(11,15,26,0.12);
      --accent: #4f46e5;
      --accent2: #22c55e;
      --danger: #ef4444;

      --card-bg: #ffffff;
      --card-stroke: rgba(11,15,26,0.14);
      --header-bg: rgba(79,70,229,0.12);

      --shadow: 0 18px 60px rgba(0,0,0,0.12);
      --shadow2: 0 10px 30px rgba(0,0,0,0.10);

      --radius: 18px;
      --radius2: 14px;

      /* Physisches Kartenformat */
      --card-w: 14cm;
      --card-h: 10cm;

      --img-max-h: 260px;
    }

    [data-theme="dark"]{
      --bg: #000000;
      --panel: rgba(20,20,20,0.55);
      --panel-solid: #0b0b0b;
      --text: #ffffff;
      --muted: rgba(255,255,255,0.64);
      --stroke: rgba(255,255,255,0.14);
      --accent: #8b5cf6;
      --accent2: #22c55e;
      --danger: #fb7185;

      --card-bg: #0a0a0a;
      --card-stroke: rgba(255,255,255,0.16);
      --header-bg: rgba(139,92,246,0.18);

      --shadow: 0 18px 60px rgba(0,0,0,0.55);
      --shadow2: 0 10px 30px rgba(0,0,0,0.45);
    }

    *{ box-sizing: border-box; }
    html, body{ height: 100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 20% 10%, rgba(79,70,229,0.12), transparent 60%),
                  radial-gradient(1200px 800px at 80% 90%, rgba(34,197,94,0.10), transparent 60%),
                  var(--bg);
      color: var(--text);
      overflow-x: hidden;
    }

    /* iOS: bessere Touch-Experience */
    button, .btn, .icon-btn, .arrow, .menu-item { -webkit-tap-highlight-color: transparent; }
    .sr-only{
      position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0;
    }

    .topbar{
      position: sticky;
      top: 0;
      z-index: 50;
      padding: max(10px, env(safe-area-inset-top)) 14px 10px 14px;
      backdrop-filter: blur(14px);
      background: linear-gradient(to bottom, rgba(0,0,0,0.08), transparent), var(--panel);
      border-bottom: 1px solid var(--stroke);
    }
    [data-theme="dark"] .topbar{
      background: linear-gradient(to bottom, rgba(255,255,255,0.06), transparent), var(--panel);
    }

    .topbar-inner{
      max-width: 1100px;
      margin: 0 auto;
      display:flex;
      align-items:center;
      gap: 10px;
      justify-content: space-between;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 160px;
    }
    .logo{
      width: 36px;
      height: 36px;
      border-radius: 12px;
      background: linear-gradient(135deg, rgba(79,70,229,0.9), rgba(34,197,94,0.75));
      box-shadow: var(--shadow2);
      border: 1px solid rgba(255,255,255,0.18);
    }
    .brand .title{
      display:flex;
      flex-direction: column;
      line-height: 1.1;
    }
    .brand .title strong{
      font-size: 14px;
      letter-spacing: 0.2px;
    }
    .brand .title span{
      font-size: 12px;
      color: var(--muted);
    }

    .controls{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .btn{
      border: 1px solid var(--stroke);
      background: var(--panel-solid);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor: pointer;
      display:inline-flex;
      align-items:center;
      gap: 10px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.08);
      transition: transform .08s ease, box-shadow .2s ease, border-color .2s ease;
      font-weight: 650;
      font-size: 13px;
      user-select:none;
    }
    [data-theme="dark"] .btn{
      background: rgba(20,20,20,0.85);
      box-shadow: 0 10px 25px rgba(0,0,0,0.45);
    }
    .btn:active{ transform: translateY(1px) scale(0.99); }
    .btn:hover{ border-color: rgba(79,70,229,0.35); }

    .btn .pill{
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(79,70,229,0.12);
      border: 1px solid rgba(79,70,229,0.18);
      font-size: 12px;
      font-weight: 750;
      color: var(--text);
    }
    [data-theme="dark"] .btn .pill{
      background: rgba(139,92,246,0.18);
      border-color: rgba(139,92,246,0.24);
    }

    .icon-btn{
      width: 44px;
      height: 44px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: var(--panel-solid);
      color: var(--text);
      cursor:pointer;
      display:grid;
      place-items:center;
      box-shadow: 0 10px 25px rgba(0,0,0,0.08);
      transition: transform .08s ease, border-color .2s ease;
      user-select:none;
      font-size: 18px;
      font-weight: 800;
    }
    [data-theme="dark"] .icon-btn{
      background: rgba(20,20,20,0.85);
      box-shadow: 0 10px 25px rgba(0,0,0,0.45);
    }
    .icon-btn:active{ transform: translateY(1px) scale(0.99); }
    .icon-btn:hover{ border-color: rgba(79,70,229,0.35); }

    .content{
      max-width: 1100px;
      margin: 0 auto;
      padding: 18px 14px 28px;
    }

    .stage{
      min-height: calc(100vh - 88px);
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 18px;
      padding: 16px 0 40px;
    }

    .arrow{
      width: clamp(46px, 10vw, 90px);
      height: clamp(46px, 12vw, 110px);
      display:grid;
      place-items:center;
      border-radius: 18px;
      border: 1px solid var(--stroke);
      background: var(--panel);
      backdrop-filter: blur(16px);
      box-shadow: var(--shadow2);
      cursor:pointer;
      user-select:none;
      transition: transform .10s ease, border-color .2s ease, opacity .2s ease;
      font-size: clamp(22px, 4.6vw, 40px);
      font-weight: 900;
      color: var(--text);
    }
    .arrow:active{ transform: translateY(1px) scale(0.99); }
    .arrow:hover{ border-color: rgba(79,70,229,0.35); }
    .arrow[aria-disabled="true"]{
      opacity: 0.35;
      pointer-events:none;
    }

    .arrow.left{
      transform: scaleX(-1);
    }
    .arrow.left:active{ transform: scaleX(-1) translateY(1px) scale(0.99); }

    .card-wrap{
      perspective: 1200px;
      width: min(var(--card-w), 92vw);
      height: auto;
    }

    /* Karte: 14cm x 10cm physisch, aber responsiv skaliert */
    .card{
      width: min(var(--card-w), 92vw);
      aspect-ratio: 14 / 10;
      border-radius: 22px;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 550ms cubic-bezier(.2,.8,.2,1);
      cursor: pointer;
      user-select:none;
      box-shadow: var(--shadow);
    }
    .card.is-flipped{
      transform: rotateY(180deg);
    }

    .card-face{
      position:absolute;
      inset:0;
      border-radius: 22px;
      background: var(--card-bg);
      border: 1px solid var(--card-stroke);
      overflow: hidden; /* Wichtig: Inhalt bleibt in Karte */
      backface-visibility: hidden;
      display:flex;
      flex-direction: column;
    }

    .card-face.back{
      transform: rotateY(180deg);
    }

    .card-header{
      flex: 0 0 auto;
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 12px 14px;
      background: linear-gradient(135deg, var(--header-bg), transparent 55%);
      border-bottom: 1px solid var(--stroke);
      min-height: 54px;
    }
    .topic-badge{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(79,70,229,0.10);
      border: 1px solid rgba(79,70,229,0.18);
      font-weight: 800;
      font-size: 13px;
      max-width: 100%;
    }
    [data-theme="dark"] .topic-badge{
      background: rgba(139,92,246,0.16);
      border-color: rgba(139,92,246,0.24);
    }
    .topic-badge span{
      display:inline-block;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 58ch;
    }

    .card-body{
      position: relative;
      flex: 1 1 auto;
      display:flex;
      min-height: 0; /* wichtig fÃ¼r overflow im child */
    }

    .side-label{
      flex: 0 0 34px;
      border-right: 1px solid var(--stroke);
      display:flex;
      align-items:center;
      justify-content:center;
      background: linear-gradient(to bottom, rgba(0,0,0,0.03), transparent);
    }
    [data-theme="dark"] .side-label{
      background: linear-gradient(to bottom, rgba(255,255,255,0.06), transparent);
    }

    .side-label .vtext{
      writing-mode: vertical-rl;
      transform: rotate(180deg);
      font-weight: 900;
      letter-spacing: 0.16em;
      font-size: 11px;
      text-transform: uppercase;
      color: var(--muted);
      user-select:none;
    }

    .main{
      flex: 1 1 auto;
      min-width: 0;
      display:flex;
      flex-direction: column;
      min-height: 0;
    }

    .card-scroll{
      flex: 1 1 auto;
      min-height: 0;
      padding: 14px 16px 10px;
      overflow: auto;
      -webkit-overflow-scrolling: touch; /* iPhone smooth */
      overscroll-behavior: contain;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .card-scroll-inner{
      width: 100%;
      max-width: 72ch;
      margin: 0 auto;
      text-align: center;
      font-size: clamp(15px, 1.9vw, 19px);
      line-height: 1.35;
      font-weight: 700;
      word-break: break-word;
      overflow-wrap: anywhere;
    }

    .card-scroll-inner p{
      margin: 0.5em 0;
      font-weight: 750;
    }
    .card-scroll-inner ul{
      margin: 0.6em auto;
      padding-left: 1.1em;
      display: inline-block;
      text-align: left;
      max-width: 100%;
      font-weight: 700;
    }
    .card-scroll-inner li{
      margin: 0.2em 0;
      font-weight: 700;
    }

    .inserted-image{
      display:block;
      width: 100%;
      max-width: 100%;
      height: auto;
      max-height: var(--img-max-h);
      margin: 10px auto;
      object-fit: contain;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,0.02);
    }
    [data-theme="dark"] .inserted-image{
      background: rgba(255,255,255,0.05);
    }

    .difficulty{
      flex: 0 0 auto;
      padding: 10px 14px 14px;
      border-top: 1px solid var(--stroke);
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 8px;
    }
    .dot{
      width: 12px; height: 12px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: transparent;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,0);
    }
    .dot.filled{
      background: linear-gradient(135deg, rgba(79,70,229,0.9), rgba(34,197,94,0.8));
      border-color: rgba(79,70,229,0.25);
    }

    .statusbar{
      margin-top: 14px;
      display:flex;
      align-items:center;
      justify-content:center;
      gap: 10px;
      color: var(--muted);
      font-size: 13px;
      font-weight: 700;
      text-align:center;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      padding: 3px 8px;
      border-radius: 10px;
      border: 1px solid var(--stroke);
      background: var(--panel-solid);
      color: var(--text);
      box-shadow: 0 10px 25px rgba(0,0,0,0.06);
    }

    /* MenÃ¼-Overlay (Custom Dropdown) */
    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      display:none;
      z-index: 100;
      padding: max(12px, env(safe-area-inset-top)) 12px max(12px, env(safe-area-inset-bottom));
    }
    .overlay.open{ display:flex; align-items:flex-start; justify-content:center; }
    .sheet{
      width: min(780px, 100%);
      border-radius: 22px;
      border: 1px solid var(--stroke);
      background: var(--panel-solid);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    [data-theme="dark"] .sheet{
      background: #0b0b0b;
    }
    .sheet-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 14px 14px;
      border-bottom: 1px solid var(--stroke);
      background: linear-gradient(135deg, rgba(79,70,229,0.10), transparent 55%);
    }
    .sheet-head strong{ font-size: 14px; letter-spacing: 0.2px; }
    .sheet-head span{ color: var(--muted); font-size: 12px; font-weight: 650; }

    .sheet-body{
      padding: 12px 14px 14px;
      max-height: min(70vh, 560px);
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }

    .sheet-actions{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items:center;
      justify-content:flex-start;
      padding-bottom: 10px;
      border-bottom: 1px dashed var(--stroke);
      margin-bottom: 12px;
    }

    .list{
      display:flex;
      flex-direction: column;
      gap: 10px;
    }

    .deck-row{
      display:flex;
      align-items:center;
      gap: 10px;
      padding: 12px 12px;
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,0.02);
    }
    [data-theme="dark"] .deck-row{
      background: rgba(255,255,255,0.04);
    }
    .deck-row.active{
      border-color: rgba(79,70,229,0.35);
      box-shadow: 0 12px 26px rgba(79,70,229,0.12);
    }

    .deck-meta{
      flex: 1 1 auto;
      min-width: 0;
      display:flex;
      flex-direction: column;
      gap: 3px;
      cursor:pointer;
    }
    .deck-meta strong{
      font-size: 13px;
      font-weight: 850;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .deck-meta small{
      color: var(--muted);
      font-size: 12px;
      font-weight: 700;
    }

    .row-actions{
      display:flex;
      align-items:center;
      gap: 8px;
      flex: 0 0 auto;
    }

    .mini{
      width: 40px; height: 40px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: var(--panel-solid);
      color: var(--text);
      cursor:pointer;
      display:grid;
      place-items:center;
      user-select:none;
      font-size: 17px;
      font-weight: 900;
    }
    [data-theme="dark"] .mini{
      background: rgba(20,20,20,0.9);
      color: #fff; /* Icons im Dark Mode weiÃŸ */
    }
    .mini.danger{
      color: var(--danger);
      border-color: rgba(239,68,68,0.25);
    }
    [data-theme="dark"] .mini.danger{
      color: #fff; /* MÃ¼lleimer im Dark Mode weiÃŸ (Pflicht) */
      border-color: rgba(255,255,255,0.2);
    }
    .mini:active{ transform: translateY(1px) scale(0.99); }

    .hint{
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
      font-weight: 650;
      line-height: 1.4;
    }

    .empty{
      text-align:center;
      padding: 18px 10px;
      color: var(--muted);
      font-weight: 750;
      font-size: 13px;
    }

    /* Mobile Optimierung */
    @media (max-width: 520px){
      :root{ --img-max-h: 190px; }
      .brand{ min-width: auto; }
      .brand .title span{ display:none; }
      .stage{ gap: 10px; padding-top: 10px; }
      .card-header{ padding: 11px 12px; min-height: 50px; }
      .card-scroll{ padding: 12px 12px 8px; }
      .difficulty{ padding: 9px 12px 12px; }
      .side-label{ flex-basis: 30px; }
    }

    /* prefers-reduced-motion */
    @media (prefers-reduced-motion: reduce){
      .card{ transition: none; }
      .btn, .icon-btn, .arrow{ transition: none; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div class="title">
          <strong>Karteikarten</strong>
          <span id="subTitle">TXT + Bilder lokal gespeichert</span>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="openMenuBtn" type="button" title="TXT-Dateien & Bilder verwalten">
          <span>ðŸ“š Dateien</span>
          <span class="pill" id="deckCountPill">0</span>
        </button>

        <button class="icon-btn" id="themeBtn" type="button" title="Dark/Light Mode">ðŸŒ™</button>
      </div>
    </div>
  </div>

  <main class="content">
    <section class="stage" aria-label="Karteikarten">
      <div class="arrow left" id="prevBtn" role="button" tabindex="0" aria-label="Vorherige Karte">
        âžœ
      </div>

      <div class="card-wrap">
        <div class="card" id="card" aria-label="Karteikarte (klicken zum Flippen)" role="button" tabindex="0">
          <!-- FRONT -->
          <div class="card-face front">
            <div class="card-header">
              <div class="topic-badge" title="Thema">
                <span id="topicFront">Kein Deck geladen</span>
              </div>
            </div>

            <div class="card-body">
              <div class="side-label"><div class="vtext">Frage</div></div>
              <div class="main">
                <div class="card-scroll" id="scrollFront">
                  <div class="card-scroll-inner" id="textFront">
                    Lade eine oder mehrere TXT-Dateien Ã¼ber â€žðŸ“š Dateienâ€œ.
                  </div>
                </div>
                <div class="difficulty" aria-label="Schwierigkeit">
                  <div class="dot" id="fDot1"></div>
                  <div class="dot" id="fDot2"></div>
                  <div class="dot" id="fDot3"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- BACK -->
          <div class="card-face back">
            <div class="card-header">
              <div class="topic-badge" title="Thema">
                <span id="topicBack">Kein Deck geladen</span>
              </div>
            </div>

            <div class="card-body">
              <div class="side-label"><div class="vtext">Antwort</div></div>
              <div class="main">
                <div class="card-scroll" id="scrollBack">
                  <div class="card-scroll-inner" id="textBack">
                    â€”
                  </div>
                </div>
                <div class="difficulty" aria-label="Schwierigkeit">
                  <div class="dot" id="bDot1"></div>
                  <div class="dot" id="bDot2"></div>
                  <div class="dot" id="bDot3"></div>
                </div>
              </div>
            </div>
          </div>

        </div>

        <div class="statusbar" id="statusBar">
          <span id="statusText">0 / 0</span>
          <span class="kbd">Klick Karte = Flip</span>
          <span class="kbd">Pfeile = Navigation</span>
        </div>
      </div>

      <div class="arrow" id="nextBtn" role="button" tabindex="0" aria-label="NÃ¤chste Karte">
        âžœ
      </div>
    </section>
  </main>

  <!-- MENU OVERLAY (Custom Dropdown) -->
  <div class="overlay" id="overlay" aria-hidden="true">
    <div class="sheet" role="dialog" aria-modal="true" aria-label="TXT-Dateien verwalten">
      <div class="sheet-head">
        <div>
          <strong>Dateien & Bilder</strong><br/>
          <span>Mehrere TXT hochladen â€¢ pro TXT eigene Bilder (IndexedDB)</span>
        </div>
        <button class="icon-btn" id="closeMenuBtn" type="button" title="SchlieÃŸen">âœ•</button>
      </div>

      <div class="sheet-body">
        <div class="sheet-actions">
          <input class="sr-only" id="txtInput" type="file" accept=".txt,text/plain" multiple />
          <button class="btn" id="uploadTxtBtn" type="button">âž• TXT hochladen</button>

          <button class="btn" id="resetFlipBtn" type="button" title="Zur Vorderseite wechseln">â†©ï¸Ž Vorderseite</button>

          <div class="hint" id="menuHint" style="margin:0;">
            Tipp: Lege Bilder mit Markern wie <span class="kbd">#Test#</span> oder <span class="kbd">#F9#</span> in Text/LÃ¶sung ein. (Case-insensitive)
          </div>
        </div>

        <div class="list" id="deckList"></div>
        <div class="empty" id="emptyMsg" style="display:none;">
          Noch keine TXT gespeichert. Lade eine TXT-Datei hoch.
        </div>

        <!-- hidden image input reused per deck -->
        <input class="sr-only" id="imgInput" type="file" accept="image/*" multiple />
      </div>
    </div>
  </div>

  <script>
    /*************************************************************
     * Storage Keys
     *************************************************************/
    const LS_DECKS_KEY = "fc_decks_v1";
    const LS_ACTIVE_DECK = "fc_active_deck_v1";
    const LS_THEME = "fc_theme_v1";

    /*************************************************************
     * IndexedDB for images (per deck)
     * Store: images
     * key: [deckId, nameLower]  (name without extension, case-insensitive)
     *************************************************************/
    const IDB_NAME = "flashcard_images_v1";
    const IDB_STORE = "images";
    let idbPromise = null;

    function openIDB(){
      if (idbPromise) return idbPromise;
      idbPromise = new Promise((resolve, reject) => {
        const req = indexedDB.open(IDB_NAME, 1);
        req.onupgradeneeded = (e) => {
          const db = req.result;
          if (!db.objectStoreNames.contains(IDB_STORE)){
            db.createObjectStore(IDB_STORE, { keyPath: ["deckId","name"] });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
      return idbPromise;
    }

    async function idbPutImage(deckId, nameLower, blob, mime){
      const db = await openIDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, "readwrite");
        tx.objectStore(IDB_STORE).put({ deckId, name: nameLower, blob, mime, ts: Date.now() });
        tx.oncomplete = () => resolve(true);
        tx.onerror = () => reject(tx.error);
      });
    }

    async function idbGetImage(deckId, nameLower){
      const db = await openIDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, "readonly");
        const req = tx.objectStore(IDB_STORE).get([deckId, nameLower]);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbDeleteDeckImages(deckId){
      const db = await openIDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, "readwrite");
        const store = tx.objectStore(IDB_STORE);
        const cursorReq = store.openCursor();
        cursorReq.onsuccess = (e) => {
          const cursor = e.target.result;
          if (!cursor) return;
          const key = cursor.key; // [deckId, name]
          if (key && key[0] === deckId){
            cursor.delete();
          }
          cursor.continue();
        };
        tx.oncomplete = () => resolve(true);
        tx.onerror = () => reject(tx.error);
      });
    }

    /*************************************************************
     * App State
     *************************************************************/
    let decks = [];         // [{id, name, raw, cards:[], createdAt, updatedAt}]
    let activeDeckId = null;
    let activeIndex = 0;
    let isFlipped = false;

    // Image object URLs to revoke on rerender
    let liveObjectUrls = [];

    /*************************************************************
     * DOM
     *************************************************************/
    const cardEl = document.getElementById("card");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");

    const topicFront = document.getElementById("topicFront");
    const topicBack  = document.getElementById("topicBack");

    const textFront = document.getElementById("textFront");
    const textBack  = document.getElementById("textBack");

    const statusText = document.getElementById("statusText");

    const fDots = [document.getElementById("fDot1"), document.getElementById("fDot2"), document.getElementById("fDot3")];
    const bDots = [document.getElementById("bDot1"), document.getElementById("bDot2"), document.getElementById("bDot3")];

    const openMenuBtn = document.getElementById("openMenuBtn");
    const closeMenuBtn = document.getElementById("closeMenuBtn");
    const overlay = document.getElementById("overlay");
    const deckList = document.getElementById("deckList");
    const emptyMsg = document.getElementById("emptyMsg");
    const deckCountPill = document.getElementById("deckCountPill");

    const txtInput = document.getElementById("txtInput");
    const uploadTxtBtn = document.getElementById("uploadTxtBtn");

    const imgInput = document.getElementById("imgInput");

    const themeBtn = document.getElementById("themeBtn");
    const resetFlipBtn = document.getElementById("resetFlipBtn");

    /*************************************************************
     * Utilities
     *************************************************************/
    function uid(){
      return "d_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function sanitizeFileBaseName(filename){
      // remove extension, trim, keep everything but control chars
      const base = filename.replace(/\.[^/.]+$/, "");
      return base.trim() || "Unbenannt";
    }

    function normalizeMarkerName(name){
      return (name || "").trim().toLowerCase();
    }

    function formatDate(ts){
      try{
        const d = new Date(ts);
        return d.toLocaleString(undefined, { year:"numeric", month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit" });
      }catch(_){ return ""; }
    }

    function setTheme(theme){
      document.documentElement.setAttribute("data-theme", theme);
      localStorage.setItem(LS_THEME, theme);
      themeBtn.textContent = theme === "dark" ? "â˜€ï¸" : "ðŸŒ™";
      themeBtn.title = theme === "dark" ? "Light Mode" : "Dark Mode";
    }

    function getTheme(){
      return localStorage.getItem(LS_THEME) || "light";
    }

    function saveDecks(){
      localStorage.setItem(LS_DECKS_KEY, JSON.stringify(decks));
      deckCountPill.textContent = String(decks.length);
    }

    function loadDecks(){
      const raw = localStorage.getItem(LS_DECKS_KEY);
      decks = raw ? safeJsonParse(raw, []) : [];
      deckCountPill.textContent = String(decks.length);
      activeDeckId = localStorage.getItem(LS_ACTIVE_DECK) || (decks[0]?.id ?? null);
    }

    function safeJsonParse(s, fallback){
      try{ return JSON.parse(s); } catch(_){ return fallback; }
    }

    function getActiveDeck(){
      return decks.find(d => d.id === activeDeckId) || null;
    }

    function setActiveDeck(id){
      activeDeckId = id;
      localStorage.setItem(LS_ACTIVE_DECK, id || "");
      activeIndex = 0;
      isFlipped = false;
      cardEl.classList.remove("is-flipped");
      renderAll();
    }

    function revokeLiveUrls(){
      for (const url of liveObjectUrls){
        try{ URL.revokeObjectURL(url); } catch(_){}
      }
      liveObjectUrls = [];
    }

    /*************************************************************
     * Robust TXT Parser
     * Format:
     * Frage: 1
     * Schwierigkeit: 1
     * Thema: Projektmanegement
     * Text:
     * ...
     * LÃ¶sungs-Titel:
     * ...
     * LÃ¶sung:
     * ...
     *
     * Values may be on next line, text/solution are multiline.
     *************************************************************/
    function parseTxt(rawText){
      const text = (rawText || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      const lines = text.split("\n");

      const norm = (s) => (s || "").trim();
      const isEmpty = (s) => norm(s) === "";

      const labels = [
        "frage",
        "schwierigkeit",
        "thema",
        "text",
        "lÃ¶sungs-titel",
        "loesungs-titel",
        "lÃ¶sung",
        "loesung"
      ];

      function isLabelLine(line){
        const t = norm(line).toLowerCase();
        // match "Label:" or "Label" alone
        // handle "LÃ¶sungs-Titel:" etc
        for (const lab of labels){
          if (t === lab + ":" || t === lab) return lab;
          if (t.startsWith(lab + ":")) return lab;
        }
        return null;
      }

      function readInlineValue(line, lab){
        const idx = line.toLowerCase().indexOf(lab);
        // extract after first ":" if present
        const colon = line.indexOf(":");
        if (colon >= 0){
          const v = line.slice(colon + 1);
          const vv = v.trim();
          return vv.length ? vv : null;
        }
        return null;
      }

      function readNextNonEmptyValue(i){
        let j = i;
        while (j < lines.length){
          const l = lines[j];
          if (!isEmpty(l) && !isLabelLine(l)) return { value: norm(l), nextIndex: j + 1 };
          if (isLabelLine(l)) return { value: "", nextIndex: j }; // next label begins
          j++;
        }
        return { value: "", nextIndex: j };
      }

      function readMultilineUntilNextLabel(startIndex){
        const out = [];
        let i = startIndex;
        while (i < lines.length){
          const l = lines[i];
          const lab = isLabelLine(l);
          if (lab) break;
          out.push(lines[i]); // keep original spacing
          i++;
        }
        // trim leading/trailing empty lines
        while (out.length && norm(out[0]) === "") out.shift();
        while (out.length && norm(out[out.length - 1]) === "") out.pop();
        return { value: out.join("\n"), nextIndex: i };
      }

      const cards = [];
      let current = null;

      function finishCard(){
        if (!current) return;
        // Require at least text or solution or any field that indicates a card
        const hasContent = (current.text && current.text.trim()) || (current.solution && current.solution.trim());
        const hasAny = current.questionNo || current.topic || current.difficulty || hasContent;
        if (hasAny){
          current.difficulty = clamp(parseInt(current.difficulty || "1", 10) || 1, 1, 3);
          current.topic = (current.topic || "").trim() || "Ohne Thema";
          current.text = (current.text || "").trim();
          current.solutionTitle = (current.solutionTitle || "").trim();
          current.solution = (current.solution || "").trim();
          cards.push(current);
        }
        current = null;
      }

      let i = 0;
      while (i < lines.length){
        const line = lines[i];
        const lab = isLabelLine(line);
        if (!lab){
          i++;
          continue;
        }

        const labNorm = lab; // one of labels lower
        // start a new card if "frage" label appears
        if (labNorm === "frage"){
          finishCard();
          current = { questionNo:"", difficulty:"1", topic:"", text:"", solutionTitle:"", solution:"" };
        }
        if (!current){
          // if file starts with something else, create a card anyway
          current = { questionNo:"", difficulty:"1", topic:"", text:"", solutionTitle:"", solution:"" };
        }

        const inline = readInlineValue(line, labNorm);

        if (labNorm === "frage"){
          if (inline !== null){
            current.questionNo = inline;
            i++;
          } else {
            const { value, nextIndex } = readNextNonEmptyValue(i + 1);
            current.questionNo = value;
            i = nextIndex;
          }
          continue;
        }

        if (labNorm === "schwierigkeit"){
          if (inline !== null){
            current.difficulty = inline;
            i++;
          } else {
            const { value, nextIndex } = readNextNonEmptyValue(i + 1);
            current.difficulty = value;
            i = nextIndex;
          }
          continue;
        }

        if (labNorm === "thema"){
          if (inline !== null){
            current.topic = inline;
            i++;
          } else {
            const { value, nextIndex } = readNextNonEmptyValue(i + 1);
            current.topic = value;
            i = nextIndex;
          }
          continue;
        }

        if (labNorm === "text"){
          // If inline exists and has content, treat as start line, but still allow following lines until next label
          let start = i + 1;
          let firstLine = "";
          if (inline !== null && inline !== ""){
            firstLine = inline;
            start = i + 1;
          } else {
            // if next line is empty, it's fine
            firstLine = "";
          }

          const { value, nextIndex } = readMultilineUntilNextLabel(start);
          current.text = (firstLine ? (firstLine + "\n" + value) : value);
          i = nextIndex;
          continue;
        }

        if (labNorm === "lÃ¶sungs-titel" || labNorm === "loesungs-titel"){
          if (inline !== null){
            current.solutionTitle = inline;
            i++;
          } else {
            const { value, nextIndex } = readNextNonEmptyValue(i + 1);
            current.solutionTitle = value;
            i = nextIndex;
          }
          continue;
        }

        if (labNorm === "lÃ¶sung" || labNorm === "loesung"){
          let start = i + 1;
          let firstLine = "";
          if (inline !== null && inline !== ""){
            firstLine = inline;
            start = i + 1;
          } else {
            firstLine = "";
          }
          const { value, nextIndex } = readMultilineUntilNextLabel(start);
          current.solution = (firstLine ? (firstLine + "\n" + value) : value);
          i = nextIndex;
          continue;
        }

        i++;
      }

      finishCard();
      return cards;
    }

    /*************************************************************
     * Render helpers: convert multiline text to DOM with markers
     *************************************************************/
    function splitByMarkers(str){
      // Matches #anything# (non-greedy; no nested #)
      const re = /#([^#]+)#/g;
      const parts = [];
      let last = 0;
      let m;
      while ((m = re.exec(str)) !== null){
        const before = str.slice(last, m.index);
        if (before) parts.push({ type: "text", value: before });
        parts.push({ type: "marker", value: m[1] });
        last = m.index + m[0].length;
      }
      const after = str.slice(last);
      if (after) parts.push({ type: "text", value: after });
      return parts;
    }

    function buildNodesFromText(text){
      // creates blocks: paragraphs + lists; preserves markers within lines
      const raw = (text || "");
      const lines = raw.split("\n");

      // build a simple structure: consecutive "- " -> list, else paragraph
      const blocks = [];
      let listBuf = [];

      const flushList = () => {
        if (listBuf.length){
          blocks.push({ type:"ul", items: listBuf.slice() });
          listBuf = [];
        }
      };

      for (const line0 of lines){
        const line = line0.replace(/\t/g, "    ");
        const t = line.trim();
        if (t.startsWith("- ")){
          listBuf.push(t.slice(2));
          continue;
        }
        flushList();
        if (t === ""){
          // treat as spacing: keep as empty paragraph gap (optional)
          blocks.push({ type:"spacer" });
        } else {
          blocks.push({ type:"p", text: line });
        }
      }
      flushList();
      return blocks;
    }

    async function renderRichText(container, deckId, text){
      container.textContent = "";
      const blocks = buildNodesFromText(text);

      for (const blk of blocks){
        if (blk.type === "spacer"){
          const p = document.createElement("p");
          p.style.margin = "0.35em 0";
          p.textContent = "";
          container.appendChild(p);
          continue;
        }

        if (blk.type === "p"){
          const p = document.createElement("p");
          await appendInlineWithMarkers(p, deckId, blk.text);
          // If paragraph ended up empty (because only missing markers), don't add
          if (p.childNodes.length) container.appendChild(p);
          continue;
        }

        if (blk.type === "ul"){
          const ul = document.createElement("ul");
          for (const item of blk.items){
            const li = document.createElement("li");
            await appendInlineWithMarkers(li, deckId, item);
            if (li.childNodes.length) ul.appendChild(li);
          }
          if (ul.childNodes.length) container.appendChild(ul);
          continue;
        }
      }

      // If everything got removed (e.g. only missing markers), keep a dash
      if (!container.childNodes.length){
        container.textContent = "â€”";
      }
    }

    async function appendInlineWithMarkers(parent, deckId, lineText){
      const parts = splitByMarkers(lineText);
      for (const part of parts){
        if (part.type === "text"){
          const s = part.value;
          // keep as text node (but trim only if whole line is empty)
          if (s) parent.appendChild(document.createTextNode(s));
          continue;
        }

        if (part.type === "marker"){
          const nameLower = normalizeMarkerName(part.value);
          if (!nameLower) continue;

          const rec = await idbGetImage(deckId, nameLower);
          if (!rec || !rec.blob){
            // marker disappears if image doesn't exist
            continue;
          }
          const url = URL.createObjectURL(rec.blob);
          liveObjectUrls.push(url);

          const img = document.createElement("img");
          img.className = "inserted-image";
          img.loading = "lazy";
          img.alt = part.value.trim();
          img.src = url;

          // Insert as block: if parent already has text nodes, finish line first
          // We'll insert the image directly inside parent; CSS makes it block-level anyway
          parent.appendChild(img);
        }
      }
    }

    function setDots(dots, difficulty){
      const d = clamp(parseInt(difficulty, 10) || 1, 1, 3);
      dots.forEach((el, idx) => {
        el.classList.toggle("filled", idx < d);
      });
    }

    function setArrowStates(total){
      prevBtn.setAttribute("aria-disabled", String(total <= 1 || activeIndex <= 0));
      nextBtn.setAttribute("aria-disabled", String(total <= 1 || activeIndex >= total - 1));
    }

    /*************************************************************
     * Main Render
     *************************************************************/
    async function renderCard(){
      revokeLiveUrls();

      const deck = getActiveDeck();
      if (!deck || !deck.cards || deck.cards.length === 0){
        topicFront.textContent = "Kein Deck geladen";
        topicBack.textContent = "Kein Deck geladen";
        textFront.textContent = "Lade eine oder mehrere TXT-Dateien Ã¼ber â€žðŸ“š Dateienâ€œ.";
        textBack.textContent = "â€”";
        setDots(fDots, 1);
        setDots(bDots, 1);
        statusText.textContent = "0 / 0";
        setArrowStates(0);
        return;
      }

      activeIndex = clamp(activeIndex, 0, deck.cards.length - 1);
      const c = deck.cards[activeIndex];

      topicFront.textContent = c.topic || "Ohne Thema";
      topicBack.textContent  = c.topic || "Ohne Thema";

      setDots(fDots, c.difficulty);
      setDots(bDots, c.difficulty);

      // Front: question text
      await renderRichText(textFront, deck.id, (c.text || "").trim());

      // Back: solution title + solution
      const backText = [
        (c.solutionTitle || "").trim(),
        (c.solution || "").trim()
      ].filter(Boolean).join("\n\n");
      await renderRichText(textBack, deck.id, backText || "â€”");

      statusText.textContent = `${activeIndex + 1} / ${deck.cards.length}`;
      setArrowStates(deck.cards.length);
    }

    function renderMenu(){
      deckList.textContent = "";
      emptyMsg.style.display = decks.length ? "none" : "block";
      deckCountPill.textContent = String(decks.length);

      for (const d of decks){
        const row = document.createElement("div");
        row.className = "deck-row" + (d.id === activeDeckId ? " active" : "");

        const meta = document.createElement("div");
        meta.className = "deck-meta";
        meta.title = "Deck auswÃ¤hlen";
        meta.innerHTML = `
          <strong>${escapeHtml(d.name || "Unbenannt")}</strong>
          <small>${(d.cards?.length ?? 0)} Karten â€¢ aktualisiert ${escapeHtml(formatDate(d.updatedAt || d.createdAt || Date.now()))}</small>
        `;
        meta.addEventListener("click", () => {
          setActiveDeck(d.id);
          closeMenu();
        });

        const actions = document.createElement("div");
        actions.className = "row-actions";

        const imgBtn = document.createElement("button");
        imgBtn.className = "mini";
        imgBtn.type = "button";
        imgBtn.title = "Bilder fÃ¼r dieses TXT hochladen";
        imgBtn.textContent = "ðŸ–¼";
        imgBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          imgInput.dataset.deckId = d.id;
          imgInput.value = "";
          imgInput.click();
        });

        const delBtn = document.createElement("button");
        delBtn.className = "mini danger";
        delBtn.type = "button";
        delBtn.title = "TXT lÃ¶schen (inkl. Bilder)";
        delBtn.textContent = "ðŸ—‘";
        delBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          const ok = confirm(`â€ž${d.name}â€œ wirklich lÃ¶schen?\n\nDas entfernt auch alle zugehÃ¶rigen Bilder (lokal).`);
          if (!ok) return;

          // Remove from array
          decks = decks.filter(x => x.id !== d.id);
          saveDecks();

          // Delete images in IDB
          try{ await idbDeleteDeckImages(d.id); } catch(_){}

          // Update active deck
          if (activeDeckId === d.id){
            activeDeckId = decks[0]?.id ?? null;
            localStorage.setItem(LS_ACTIVE_DECK, activeDeckId || "");
            activeIndex = 0;
            isFlipped = false;
            cardEl.classList.remove("is-flipped");
          }

          renderAll();
        });

        actions.appendChild(imgBtn);
        actions.appendChild(delBtn);

        row.appendChild(meta);
        row.appendChild(actions);
        deckList.appendChild(row);
      }
    }

    async function renderAll(){
      renderMenu();
      await renderCard();
    }

    function escapeHtml(s){
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    /*************************************************************
     * Navigation & Flip
     *************************************************************/
    async function prevCard(){
      const deck = getActiveDeck();
      if (!deck || deck.cards.length === 0) return;
      if (activeIndex <= 0) return;
      activeIndex--;
      isFlipped = false;
      cardEl.classList.remove("is-flipped");
      await renderCard();
    }

    async function nextCard(){
      const deck = getActiveDeck();
      if (!deck || deck.cards.length === 0) return;
      if (activeIndex >= deck.cards.length - 1) return;
      activeIndex++;
      isFlipped = false;
      cardEl.classList.remove("is-flipped");
      await renderCard();
    }

    function flipCard(){
      const deck = getActiveDeck();
      if (!deck || deck.cards.length === 0) return;
      isFlipped = !isFlipped;
      cardEl.classList.toggle("is-flipped", isFlipped);
    }

    /*************************************************************
     * Menu open/close
     *************************************************************/
    function openMenu(){
      overlay.classList.add("open");
      overlay.setAttribute("aria-hidden", "false");
    }
    function closeMenu(){
      overlay.classList.remove("open");
      overlay.setAttribute("aria-hidden", "true");
    }

    /*************************************************************
     * TXT Upload
     *************************************************************/
    async function handleTxtFiles(fileList){
      const files = Array.from(fileList || []).filter(f => f && f.name && (f.type === "text/plain" || f.name.toLowerCase().endsWith(".txt")));
      if (!files.length) return;

      for (const f of files){
        const raw = await readFileAsText(f);
        const cards = parseTxt(raw);

        const deckId = uid();
        const name = sanitizeFileBaseName(f.name);

        decks.unshift({
          id: deckId,
          name,
          raw,
          cards,
          createdAt: Date.now(),
          updatedAt: Date.now()
        });
      }

      saveDecks();
      // Auto-activate newest
      if (!activeDeckId && decks[0]) activeDeckId = decks[0].id;
      if (decks[0]) setActiveDeck(decks[0].id);

      renderAll();
    }

    function readFileAsText(file){
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result || ""));
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file, "utf-8");
      });
    }

    /*************************************************************
     * Image Upload per Deck (IndexedDB)
     *************************************************************/
    async function handleImageFiles(deckId, fileList){
      const files = Array.from(fileList || []).filter(f => f && f.type && f.type.startsWith("image/"));
      if (!deckId || !files.length) return;

      for (const f of files){
        const base = sanitizeFileBaseName(f.name);
        const key = normalizeMarkerName(base);
        if (!key) continue;

        // Store blob directly
        try{
          await idbPutImage(deckId, key, f, f.type || "image/*");
        }catch(e){
          console.warn("IDB put failed", e);
        }
      }

      // If current deck affected, re-render (markers might now resolve)
      if (activeDeckId === deckId){
        await renderCard();
      }
    }

    /*************************************************************
     * Events
     *************************************************************/
    prevBtn.addEventListener("click", prevCard);
    nextBtn.addEventListener("click", nextCard);

    prevBtn.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); prevCard(); }
    });
    nextBtn.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); nextCard(); }
    });

    cardEl.addEventListener("click", flipCard);
    cardEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); flipCard(); }
      if (e.key === "ArrowLeft") { e.preventDefault(); prevCard(); }
      if (e.key === "ArrowRight"){ e.preventDefault(); nextCard(); }
    });

    openMenuBtn.addEventListener("click", openMenu);
    closeMenuBtn.addEventListener("click", closeMenu);

    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) closeMenu();
    });

    uploadTxtBtn.addEventListener("click", () => {
      txtInput.value = "";
      txtInput.click();
    });

    txtInput.addEventListener("change", async (e) => {
      await handleTxtFiles(e.target.files);
    });

    imgInput.addEventListener("change", async (e) => {
      const deckId = imgInput.dataset.deckId;
      await handleImageFiles(deckId, e.target.files);
      // keep menu open
      imgInput.value = "";
    });

    themeBtn.addEventListener("click", () => {
      const cur = document.documentElement.getAttribute("data-theme") || "light";
      setTheme(cur === "dark" ? "light" : "dark");
    });

    resetFlipBtn.addEventListener("click", () => {
      isFlipped = false;
      cardEl.classList.remove("is-flipped");
    });

    // Swipe support (optional but helps on mobile)
    let touchStartX = null;
    let touchStartY = null;
    let touchStartT = 0;

    function onTouchStart(e){
      if (!e.touches || e.touches.length !== 1) return;
      const t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
      touchStartT = Date.now();
    }
    async function onTouchEnd(e){
      if (touchStartX === null) return;
      const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
      if (!t) { touchStartX = null; touchStartY = null; return; }

      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const dt = Date.now() - touchStartT;

      touchStartX = null; touchStartY = null;

      // ignore long drags / vertical scroll gestures
      if (dt > 650) return;
      if (Math.abs(dy) > Math.abs(dx) * 1.2) return;

      if (dx > 60) await prevCard();
      if (dx < -60) await nextCard();
    }
    // attach to stage so scrolling inside card still works
    document.querySelector(".stage").addEventListener("touchstart", onTouchStart, { passive: true });
    document.querySelector(".stage").addEventListener("touchend", onTouchEnd, { passive: true });

    /*************************************************************
     * Init
     *************************************************************/
    (async function init(){
      setTheme(getTheme());
      loadDecks();

      // If active deck missing, fix
      if (activeDeckId && !decks.some(d => d.id === activeDeckId)){
        activeDeckId = decks[0]?.id ?? null;
        localStorage.setItem(LS_ACTIVE_DECK, activeDeckId || "");
      }

      // Ensure IDB opens early (helps iOS prompt timing)
      try{ await openIDB(); } catch(_){}

      await renderAll();

      // Accessibility: ESC closes menu
      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && overlay.classList.contains("open")){
          closeMenu();
        }
        // arrows for navigation (when menu not open)
        if (!overlay.classList.contains("open")){
          if (e.key === "ArrowLeft") prevCard();
          if (e.key === "ArrowRight") nextCard();
        }
      });
    })();
  </script>
</body>
</html>
