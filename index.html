<!doctype html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Karteikarten (offline)</title>
  <style>
    :root{
      --bg:#f5f6f8;
      --panel:#ffffff;
      --text:#111;
      --muted:#666;
      --border:#d9dde3;
      --shadow: 0 10px 30px rgba(0,0,0,.12);
      --btn:#111;
      --btnText:#fff;
      --danger:#c62828;
      --accent:#111;
      --focus: rgba(17,17,17,.14);
    }
    [data-theme="dark"]{
      --bg:#000;
      --panel:#0f0f10;
      --text:#fff;
      --muted:#b8b8b8;
      --border:#2a2a2a;
      --shadow: 0 10px 30px rgba(0,0,0,.65);
      --btn:#fff;
      --btnText:#000;
      --danger:#ff5b5b;
      --accent:#fff;
      --focus: rgba(255,255,255,.14);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      overflow-x:hidden;
    }

    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
    }

    /* Top bar */
    .topbar{
      position:sticky;
      top:0;
      z-index:20;
      background:var(--bg);
      padding:12px 12px 10px;
    }
    .topbar-inner{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      max-width:1100px;
      margin:0 auto;
    }
    .group{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      min-width:0;
    }

    .btn{
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      border-radius:14px;
      padding:10px 12px;
      font-size:14px;
      line-height:1;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn.primary{
      background:var(--btn);
      color:var(--btnText);
      border-color:transparent;
    }
    .btn.icon{
      width:42px;
      height:42px;
      justify-content:center;
      padding:0;
      border-radius:14px;
    }
    .btn:active{ transform: translateY(1px); }
    .btn:focus-visible{
      outline: none;
      box-shadow: 0 0 0 4px var(--focus);
    }

    /* Icons */
    .ico{
      width:18px;
      height:18px;
      display:inline-block;
      vertical-align:middle;
      color: currentColor;
    }
    .ico.big{ width:20px; height:20px; }
    .stroke{
      fill:none;
      stroke:currentColor;
      stroke-width:2;
      stroke-linecap:round;
      stroke-linejoin:round;
    }

    /* Custom dropdown */
    .dd{
      position:relative;
      width: min(520px, 78vw);
      max-width: min(560px, 84vw);
      min-width: min(320px, 74vw);
    }
    .dd-btn{
      width:100%;
      justify-content:space-between;
      padding:12px 12px 12px 14px;
      border-radius:16px;
    }
    .dd-btn .left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
    }
    .dd-btn .name{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-weight:650;
    }
    .dd-btn .meta{
      color:var(--muted);
      font-size:12px;
      font-weight:600;
      white-space:nowrap;
    }
    .dd-btn .caret{
      color:var(--muted);
      font-size:14px;
      margin-left:10px;
    }

    .dd-menu{
      position:absolute;
      left:0;
      right:0;
      top: calc(100% + 10px);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius:18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:none;
      max-height: min(56vh, 420px);
    }
    .dd.open .dd-menu{ display:block; }

    .dd-list{
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      max-height: min(56vh, 420px);
    }

    .dd-item{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 10px;
      border-bottom:1px solid var(--border);
    }
    .dd-item:last-child{ border-bottom:none; }

    .dd-item-main{
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:2px;
      cursor:pointer;
      padding:6px 8px;
      border-radius:14px;
      -webkit-tap-highlight-color: transparent;
    }
    .dd-item-main:hover{ background: rgba(0,0,0,.04); }
    [data-theme="dark"] .dd-item-main:hover{ background: rgba(255,255,255,.06); }

    .dd-item-title{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .dd-item-title .tname{
      font-weight:750;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color: var(--muted);
      font-weight:700;
      border: 1px solid var(--border);
      padding: 3px 8px;
      border-radius:999px;
      background: transparent;
      flex: 0 0 auto;
    }

    .dd-item-sub{
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .dd-actions{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .mini{
      width:40px;
      height:40px;
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      border:1px solid var(--border);
      background: transparent;
      color: var(--text);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .mini:hover{ background: rgba(0,0,0,.04); }
    [data-theme="dark"] .mini:hover{ background: rgba(255,255,255,.06); }
    .mini.danger{
      color: var(--danger);
      border-color: transparent;
    }
    .mini.danger:hover{ background: rgba(198,40,40,.08); }
    [data-theme="dark"] .mini.danger:hover{ background: rgba(255,91,91,.10); }

    .dd-footer{
      padding:10px;
      border-top:1px solid var(--border);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .dd-footer .small{
      color:var(--muted);
      font-size:12px;
    }

    .hint{
      max-width:1100px;
      margin:6px auto 0;
      padding:0 2px;
      color:var(--muted);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }

    /* Main stage */
    .stage{
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px 10px 24px;
    }

    .nav{
      display:flex;
      align-items:center;
      justify-content:center;
      width: min(18vw, 120px);
      min-width: 54px;
      height: min(70vh, 520px);
    }
    .arrow{
      border:none;
      background:transparent;
      color:var(--accent);
      font-size: min(9vh, 70px);
      line-height:1;
      cursor:pointer;
      padding: 12px 8px;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .arrow.left{ transform: scaleX(-1); }
    .arrow[disabled]{ opacity:.25; cursor:default; }

    .center{
      display:flex;
      align-items:center;
      justify-content:center;
      width: min(92vw, 860px);
    }

    /* Card */
    .card-wrap{
      perspective: 1200px;
      width: 14cm;
      height: 10cm;
      max-width: 92vw;
      max-height: 66vh;
      aspect-ratio: 14 / 10;
    }
    .card{
      width:100%;
      height:100%;
      position:relative;
      transform-style:preserve-3d;
      transition: transform .55s cubic-bezier(.2,.8,.2,1);
      border-radius:20px;
      box-shadow: var(--shadow);
    }
    .card.flipped{ transform: rotateY(180deg); }

    .face{
      position:absolute;
      inset:0;
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:20px;
      backface-visibility:hidden;
      overflow:hidden;
      display:flex;
      flex-direction:column;
      /* IMPORTANT for iOS scroll: */
      min-height:0;
      min-width:0;
    }
    .face.back{ transform: rotateY(180deg); }

    .header{
      height: 44px;
      min-height:44px;
      display:flex;
      align-items:center;
      padding: 0 14px 0 54px;
      border-bottom:1px solid var(--border);
      font-weight:800;
      letter-spacing:.2px;
      color:var(--text);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      flex: 0 0 auto;
    }

    /* IMPORTANT: flex column + min-height:0 fixes iOS front scroll */
    .content-area{
      position:relative;
      flex:1;
      display:flex;
      flex-direction:column;
      min-height:0;
      min-width:0;
      overflow:hidden;
    }

    /* Vertical label on left edge, centered */
    .side-label{
      position:absolute;
      left: 10px;
      top:50%;
      transform: translateY(-50%) rotate(180deg);
      writing-mode: vertical-rl;
      font-weight:900;
      letter-spacing: .8px;
      font-size: 12px;
      color: var(--muted);
      user-select:none;
      pointer-events:none;
      z-index:2;
    }

    /* SCROLL AREA */
    .scroll{
      flex:1;
      min-height:0;
      min-width:0;

      padding: 12px 14px 10px 54px;

      overflow-y: auto;
      -webkit-overflow-scrolling: touch;

      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:12px;

      /* iOS: make sure it can scroll even inside 3D transformed parent */
      position: relative;
      z-index:1;
      overscroll-behavior: contain;
      touch-action: pan-y;
    }

    /* IMPORTANT: On iOS, front face sometimes doesn't accept scroll
       because the card click handler catches the touch.
       So we allow scroll to capture the gesture and stop it from flipping. */
    .scroll, .scroll *{
      -webkit-user-select: text;
      user-select: text;
    }

    .main-text{
      font-size: 18px;
      line-height:1.35;
      text-align:center;
      color: var(--text);
      word-break: break-word;
      white-space: pre-wrap;
    }

    .inline-img{
      width: 100%;
      max-width: 100%;
      height:auto;
      max-height: 260px;
      object-fit: contain;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: transparent;
    }

    .difficulty{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      margin-top: 2px;
      flex: 0 0 auto;
    }
    .dot{
      width:12px;
      height:12px;
      border-radius:999px;
      border: 2px solid var(--muted);
      opacity:.85;
    }
    .dot.filled{
      border-color: var(--accent);
      background: var(--accent);
      opacity:1;
    }

    .footer{
      height: 54px;
      min-height:54px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 0 14px 0 14px;
      border-top:1px solid var(--border);
      color:var(--muted);
      font-size:12px;
      gap:12px;
      flex: 0 0 auto;
    }
    .footer .meta{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      min-width:0;
    }
    .kbd{
      border:1px solid var(--border);
      border-bottom-width:2px;
      padding:2px 6px;
      border-radius:8px;
      font-size:11px;
      color:var(--muted);
      background: var(--panel);
      white-space:nowrap;
    }

    .empty{
      text-align:center;
      color:var(--muted);
      padding: 18px;
      border:1px dashed var(--border);
      border-radius:18px;
      width:min(520px, 92vw);
      background: transparent;
    }

    /* Modal */
    .modal-backdrop{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:999;
      padding: 14px;
    }
    .modal-backdrop.open{ display:flex; }

    .modal{
      width: min(720px, 96vw);
      max-height: min(78vh, 720px);
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 20px;
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .modal-header{
      padding: 14px 14px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom: 1px solid var(--border);
    }
    .modal-title{
      font-weight:900;
      letter-spacing:.2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .modal-body{
      padding: 12px 12px 12px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }
    .img-row{
      display:flex;
      gap:12px;
      align-items:center;
      border:1px solid var(--border);
      border-radius: 16px;
      padding: 10px;
    }
    .img-thumb{
      width: 74px;
      height: 54px;
      border-radius: 12px;
      border:1px solid var(--border);
      object-fit: cover;
      flex: 0 0 auto;
      background: transparent;
    }
    .img-info{
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:3px;
    }
    .img-name{
      font-weight:850;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .img-sub{
      color: var(--muted);
      font-size: 12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .modal-footer{
      border-top: 1px solid var(--border);
      padding: 12px;
      display:flex;
      gap:10px;
      justify-content:space-between;
      flex-wrap:wrap;
      align-items:center;
    }

    @media (max-width: 520px){
      .topbar{ padding: 10px 10px 8px; }
      .dd{ min-width: 62vw; }
      .btn{ padding: 10px 10px; }
      .btn.icon{ width:40px; height:40px; }
      .arrow{ font-size: 56px; }
      .header{ height: 42px; min-height:42px; font-size: 14px; padding-left: 50px; }
      .scroll{ padding-left: 50px; }
      .main-text{ font-size: 16px; }
      .inline-img{ max-height: 180px; }
      .side-label{ left: 9px; font-size: 11px; }
      .footer{ height: 52px; min-height:52px; }
      .mini{ width:38px; height:38px; }
      .img-thumb{ width: 64px; height: 48px; }
    }
  </style>
</head>
<body>
<div class="app" id="app">
  <div class="topbar">
    <div class="topbar-inner">
      <div class="group" style="flex:1;">
        <div class="dd" id="dd">
          <button class="btn dd-btn" id="ddBtn" type="button" aria-haspopup="listbox" aria-expanded="false">
            <div class="left">
              <span id="ddTitle" class="name">Keine TXT geladen</span>
              <span id="ddMeta" class="meta"></span>
            </div>
            <span class="caret">▾</span>
          </button>

          <div class="dd-menu" id="ddMenu">
            <div class="dd-list" id="ddList"></div>
            <div class="dd-footer">
              <div class="small">Jede TXT hat ihre eigenen Bilder (IndexedDB).</div>
              <button class="btn primary" id="btnUploadTxt" type="button">TXT Upload</button>
            </div>
          </div>
        </div>
      </div>

      <div class="group">
        <button class="btn icon" id="btnTheme" type="button" title="Theme wechseln">
          <span id="themeIcon"></span>
        </button>
      </div>
    </div>

    <div class="hint">
      <div id="statusLeft">Offline • Lokal gespeichert</div>
      <div id="statusRight" style="text-align:right;">Klick Karte = Flip • Pfeile = Navigieren</div>
    </div>
  </div>

  <div class="stage">
    <div class="nav">
      <button class="arrow left" id="prevBtn" type="button" aria-label="Vorherige Karte">➜</button>
    </div>

    <div class="center">
      <div id="emptyState" class="empty" style="display:none;">
        <div style="font-weight:900; color:var(--text); margin-bottom:6px;">Keine Karteikarten</div>
        <div>Upload eine oder mehrere <b>.txt</b> Dateien.</div>
      </div>

      <div class="card-wrap" id="cardWrap" style="display:none;">
        <div class="card" id="card" role="button" aria-label="Karte umdrehen" tabindex="0">
          <div class="face front">
            <div class="header" id="topicFront">Thema</div>

            <!-- IMPORTANT CHANGE: front scroll is now a separate element
                 and we prevent the card-click from stealing the scroll gesture -->
            <div class="content-area">
              <div class="side-label">Frage</div>
              <div class="scroll" id="scrollFront">
                <div class="main-text" id="textFront"></div>
                <div class="difficulty" id="diffFront">
                  <div class="dot"></div><div class="dot"></div><div class="dot"></div>
                </div>
              </div>
            </div>

            <div class="footer">
              <div class="meta" id="metaFront">—</div>
              <div class="kbd">← / →</div>
            </div>
          </div>

          <div class="face back">
            <div class="header" id="topicBack">Thema</div>
            <div class="content-area">
              <div class="side-label">Antwort</div>
              <div class="scroll" id="scrollBack">
                <div class="main-text" id="textBack"></div>
                <div class="difficulty" id="diffBack">
                  <div class="dot"></div><div class="dot"></div><div class="dot"></div>
                </div>
              </div>
            </div>
            <div class="footer">
              <div class="meta" id="metaBack">—</div>
              <div class="kbd">Esc = Flip</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="nav">
      <button class="arrow" id="nextBtn" type="button" aria-label="Nächste Karte">➜</button>
    </div>
  </div>
</div>

<!-- Modal for images -->
<div class="modal-backdrop" id="imgModalBackdrop" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="imgModalTitle">
    <div class="modal-header">
      <div class="modal-title" id="imgModalTitle">Bilder</div>
      <button class="btn icon" id="btnCloseImgModal" type="button" title="Schließen">
        <span id="closeIcon"></span>
      </button>
    </div>

    <div class="modal-body" id="imgModalBody"></div>

    <div class="modal-footer">
      <div style="display:flex; gap:10px; flex-wrap:wrap;">
        <button class="btn primary" id="btnAddImagesModal" type="button">
          <span id="addImgIcon"></span>
          <span>Bilder hinzufügen</span>
        </button>
        <button class="btn" id="btnDeleteAllImages" type="button">
          <span id="trashAllIcon"></span>
          <span>Alle löschen</span>
        </button>
      </div>

      <div style="color:var(--muted); font-size:12px;" id="imgModalCount">—</div>
    </div>
  </div>
</div>

<!-- Hidden inputs -->
<input id="txtInput" type="file" accept=".txt,text/plain" multiple style="display:none;" />
<input id="imgInput" type="file" accept="image/*" multiple style="display:none;" />

<script>
(() => {
  const LS_LIST_KEY = "fc_txt_list_v6";
  const LS_THEME_KEY = "fc_theme_v1";
  const LS_LAST_TXT_KEY = "fc_last_txt_v1";
  const LS_CONTENT_PREFIX = "fc_txt_content_v1_";

  // UI
  const dd = document.getElementById("dd");
  const ddBtn = document.getElementById("ddBtn");
  const ddList = document.getElementById("ddList");
  const ddTitle = document.getElementById("ddTitle");
  const ddMeta = document.getElementById("ddMeta");
  const btnUploadTxt = document.getElementById("btnUploadTxt");

  const btnTheme = document.getElementById("btnTheme");
  const themeIcon = document.getElementById("themeIcon");

  const txtInput = document.getElementById("txtInput");
  const imgInput = document.getElementById("imgInput");

  const emptyState = document.getElementById("emptyState");
  const cardWrap = document.getElementById("cardWrap");
  const cardEl = document.getElementById("card");
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");

  const topicFront = document.getElementById("topicFront");
  const topicBack = document.getElementById("topicBack");
  const textFront = document.getElementById("textFront");
  const textBack = document.getElementById("textBack");
  const diffFront = document.getElementById("diffFront");
  const diffBack = document.getElementById("diffBack");
  const metaFront = document.getElementById("metaFront");
  const metaBack = document.getElementById("metaBack");
  const statusLeft = document.getElementById("statusLeft");

  // IMPORTANT: front/back scroll elements
  const scrollFront = document.getElementById("scrollFront");
  const scrollBack = document.getElementById("scrollBack");

  // Image modal
  const imgModalBackdrop = document.getElementById("imgModalBackdrop");
  const imgModalBody = document.getElementById("imgModalBody");
  const imgModalTitle = document.getElementById("imgModalTitle");
  const imgModalCount = document.getElementById("imgModalCount");
  const btnCloseImgModal = document.getElementById("btnCloseImgModal");
  const btnAddImagesModal = document.getElementById("btnAddImagesModal");
  const btnDeleteAllImages = document.getElementById("btnDeleteAllImages");
  const addImgIcon = document.getElementById("addImgIcon");
  const trashAllIcon = document.getElementById("trashAllIcon");
  const closeIcon = document.getElementById("closeIcon");

  // State
  let txtList = [];
  let currentTxtId = "";
  let currentTxtName = "";
  let cards = [];
  let idx = 0;
  let isFlipped = false;

  // ---------- Icons ----------
  function svgPhoto(){
    return `
      <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
        <rect class="stroke" x="3" y="5" width="18" height="14" rx="2"/>
        <path class="stroke" d="M7 15l3-3 3 3 3-4 2 4"/>
        <circle class="stroke" cx="9" cy="9" r="1.2"/>
      </svg>
    `;
  }
  function svgTrash(){
    return `
      <svg class="ico" viewBox="0 0 24 24" aria-hidden="true">
        <path class="stroke" d="M4 7h16"/>
        <path class="stroke" d="M10 11v7"/>
        <path class="stroke" d="M14 11v7"/>
        <path class="stroke" d="M6 7l1 14a2 2 0 0 0 2 2h6a2 2 0 0 0 2-2l1-14"/>
        <path class="stroke" d="M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"/>
      </svg>
    `;
  }
  function svgSun(){
    return `
      <svg class="ico big" viewBox="0 0 24 24" aria-hidden="true">
        <circle class="stroke" cx="12" cy="12" r="4"/>
        <path class="stroke" d="M12 2v2"/>
        <path class="stroke" d="M12 20v2"/>
        <path class="stroke" d="M4.93 4.93l1.41 1.41"/>
        <path class="stroke" d="M17.66 17.66l1.41 1.41"/>
        <path class="stroke" d="M2 12h2"/>
        <path class="stroke" d="M20 12h2"/>
        <path class="stroke" d="M4.93 19.07l1.41-1.41"/>
        <path class="stroke" d="M17.66 6.34l1.41-1.41"/>
      </svg>
    `;
  }
  function svgMoonStars(){
    return `
      <svg class="ico big" viewBox="0 0 24 24" aria-hidden="true">
        <path class="stroke" d="M20.5 15.5A8 8 0 0 1 9.5 3.5a7 7 0 1 0 11 12z"/>
        <path class="stroke" d="M5.2 6.2l.7 1.3 1.3.7-1.3.7-.7 1.3-.7-1.3-1.3-.7 1.3-.7.7-1.3z"/>
        <path class="stroke" d="M17.2 6.5l.5 1 .9.5-.9.5-.5 1-.5-1-.9-.5.9-.5.5-1z"/>
      </svg>
    `;
  }
  function svgClose(){
    return `
      <svg class="ico big" viewBox="0 0 24 24" aria-hidden="true">
        <path class="stroke" d="M6 6l12 12"/>
        <path class="stroke" d="M18 6l-12 12"/>
      </svg>
    `;
  }

  function badgeImages(){
    return `
      <span class="badge" title="Diese TXT hat Bilder">
        ${svgPhoto()}
        <span>Bilder</span>
      </span>
    `;
  }

  // ---------- IndexedDB ----------
  const DB_NAME = "flashcards_images_v6";
  const DB_VERSION = 1;
  const STORE = "images";

  function openDB(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE)) {
          const store = db.createObjectStore(STORE, { keyPath: "key" });
          store.createIndex("byTxt", "txtId", { unique: false });
          store.createIndex("byTxtName", ["txtId","name"], { unique: true });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbPutImage(txtId, nameLower, blob, mime){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      tx.objectStore(STORE).put({
        key: `${txtId}::${nameLower}`,
        txtId,
        name: nameLower,
        blob,
        mime: mime || (blob && blob.type) || "application/octet-stream",
        addedAt: Date.now()
      });
      tx.oncomplete = () => { db.close(); resolve(true); };
      tx.onerror = () => { const e = tx.error; db.close(); reject(e); };
    });
  }

  async function idbGetImage(txtId, nameLower){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readonly");
      const req = tx.objectStore(STORE).get(`${txtId}::${nameLower}`);
      req.onsuccess = () => { const r = req.result; db.close(); resolve(r || null); };
      req.onerror = () => { const e = req.error; db.close(); reject(e); };
    });
  }

  async function idbListImagesForTxt(txtId){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readonly");
      const store = tx.objectStore(STORE);
      const idxByTxt = store.index("byTxt");
      const range = IDBKeyRange.only(txtId);

      const out = [];
      const req = idxByTxt.openCursor(range);
      req.onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor){
          out.push(cursor.value);
          cursor.continue();
        }
      };
      tx.oncomplete = () => { db.close(); resolve(out); };
      tx.onerror = () => { const e = tx.error; db.close(); reject(e); };
    });
  }

  async function idbDeleteImage(txtId, nameLower){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      tx.objectStore(STORE).delete(`${txtId}::${nameLower}`);
      tx.oncomplete = () => { db.close(); resolve(true); };
      tx.onerror = () => { const e = tx.error; db.close(); reject(e); };
    });
  }

  async function idbDeleteImagesForTxt(txtId){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      const store = tx.objectStore(STORE);
      const idxByTxt = store.index("byTxt");
      const range = IDBKeyRange.only(txtId);
      const req = idxByTxt.openCursor(range);
      req.onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor) {
          store.delete(cursor.primaryKey);
          cursor.continue();
        }
      };
      tx.oncomplete = () => { db.close(); resolve(true); };
      tx.onerror = () => { const e = tx.error; db.close(); reject(e); };
    });
  }

  async function idbCountImagesForTxt(txtId){
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readonly");
      const store = tx.objectStore(STORE);
      const idxByTxt = store.index("byTxt");
      const range = IDBKeyRange.only(txtId);

      let count = 0;
      const req = idxByTxt.openCursor(range);
      req.onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor){
          count++;
          cursor.continue();
        }
      };
      tx.oncomplete = () => { db.close(); resolve(count); };
      tx.onerror = () => { const e = tx.error; db.close(); reject(e); };
    });
  }

  // ---------- LocalStorage ----------
  function loadTxtList(){
    try{
      const raw = localStorage.getItem(LS_LIST_KEY);
      txtList = raw ? JSON.parse(raw) : [];
      if (!Array.isArray(txtList)) txtList = [];
    }catch{
      txtList = [];
    }
  }
  function saveTxtList(){ localStorage.setItem(LS_LIST_KEY, JSON.stringify(txtList)); }
  function saveTxtContent(id, content){ localStorage.setItem(LS_CONTENT_PREFIX + id, content); }
  function getTxtContent(id){ return localStorage.getItem(LS_CONTENT_PREFIX + id) || ""; }
  function deleteTxtContent(id){ localStorage.removeItem(LS_CONTENT_PREFIX + id); }
  function makeId(){ return "t" + Date.now().toString(36) + Math.random().toString(36).slice(2,8); }

  // ---------- Parser ----------
  function parseTXT(raw){
    const text = (raw || "").replace(/\r\n?/g, "\n");
    const lines = text.split("\n");

    const keyMap = [
      { re: /^frage\s*:\s*(.*)$/i, key: "frage", multi:false },
      { re: /^schwierigkeit\s*:\s*(.*)$/i, key: "schwierigkeit", multi:false },
      { re: /^thema\s*:\s*(.*)$/i, key: "thema", multi:false },
      { re: /^text\s*:\s*(.*)$/i, key: "text", multi:true },
      { re: /^lösungs-?titel\s*:\s*(.*)$/i, key: "loesungstitel", multi:false },
      { re: /^lösung\s*:\s*(.*)$/i, key: "loesung", multi:true },
    ];

    const cards = [];
    let cur = null;
    let mode = null;

    function ensureCard(){
      if (!cur) cur = { frageNr:"", schwierigkeit:1, thema:"", text:"", loesungstitel:"", loesung:"" };
    }
    function pushCardIfValid(){
      if (!cur) return;
      const hasAny =
        (cur.text && cur.text.trim()) ||
        (cur.loesung && cur.loesung.trim()) ||
        (cur.thema && cur.thema.trim()) ||
        (cur.frageNr && String(cur.frageNr).trim());
      if (hasAny) {
        let d = parseInt(String(cur.schwierigkeit || "1"), 10);
        if (!Number.isFinite(d)) d = 1;
        d = Math.max(1, Math.min(3, d));
        cur.schwierigkeit = d;

        cur.text = (cur.text || "").trimEnd();
        cur.loesung = (cur.loesung || "").trimEnd();
        cur.thema = (cur.thema || "").trim();
        cur.loesungstitel = (cur.loesungstitel || "").trim();
        cur.frageNr = (cur.frageNr || "").toString().trim();
        cards.push(cur);
      }
      cur = null;
      mode = null;
    }
    function takeNextNonEmptyValue(startIndex){
      for (let j = startIndex; j < lines.length; j++){
        const v = (lines[j] ?? "").trim();
        if (v !== "") return { value: lines[j], index: j };
      }
      return { value: "", index: startIndex };
    }

    for (let i = 0; i < lines.length; i++){
      const line = lines[i];

      let matched = null;
      for (const km of keyMap){
        const m = line.match(km.re);
        if (m){ matched = { ...km, value: (m[1] ?? "") }; break; }
      }

      if (matched){
        if (matched.key === "frage"){
          if (cur) pushCardIfValid();
          ensureCard();
          let val = (matched.value || "").trim();
          if (!val){
            const nx = takeNextNonEmptyValue(i+1);
            val = (nx.value || "").trim();
            if (nx.index > i) i = nx.index;
          }
          cur.frageNr = val;
          mode = null;
          continue;
        }

        ensureCard();
        let val = matched.value;
        if ((val || "").trim() === ""){
          const nx = takeNextNonEmptyValue(i+1);
          val = nx.value || "";
          if (nx.index > i) i = nx.index;
        }

        if (matched.multi){
          mode = matched.key;
          cur[matched.key] = (val ?? "");
        } else {
          mode = null;
          if (matched.key === "schwierigkeit") cur.schwierigkeit = (val || "").trim();
          else cur[matched.key] = (val ?? "");
        }
        continue;
      }

      if (mode === "text" || mode === "loesung"){
        ensureCard();
        const existing = cur[mode] || "";
        cur[mode] = existing === "" ? line : (existing + "\n" + line);
      }
    }

    if (cur) pushCardIfValid();
    if (cards.length === 0 && text.trim()){
      cards.push({ frageNr:"", schwierigkeit:1, thema:"", text:text.trim(), loesungstitel:"", loesung:"" });
    }
    return cards;
  }

  // ---------- Markers ----------
  function clearNode(node){ while(node.firstChild) node.removeChild(node.firstChild); }
  function getMarkerParts(str){
    const s = String(str ?? "");
    const parts = [];
    const re = /#([^#]+)#/g;
    let last = 0, m;
    while ((m = re.exec(s)) !== null){
      if (m.index > last) parts.push({ type:"text", value: s.slice(last, m.index) });
      parts.push({ type:"marker", value: (m[1] || "").trim() });
      last = m.index + m[0].length;
    }
    if (last < s.length) parts.push({ type:"text", value: s.slice(last) });
    return parts;
  }

  async function renderMixedFlow(targetEl, rawText){
    clearNode(targetEl);

    const flow = document.createElement("div");
    flow.style.display = "flex";
    flow.style.flexDirection = "column";
    flow.style.gap = "12px";
    flow.style.alignItems = "center";
    flow.style.justifyContent = "center";

    const parts = getMarkerParts(rawText);

    for (const p of parts){
      if (p.type === "text"){
        const t = p.value;
        if (t !== ""){
          const block = document.createElement("div");
          block.className = "main-text";
          block.textContent = t;
          flow.appendChild(block);
        }
      } else {
        const nameLower = String(p.value || "").toLowerCase();
        if (!nameLower || !currentTxtId) continue;

        try{
          const rec = await idbGetImage(currentTxtId, nameLower);
          if (rec && rec.blob){
            const img = document.createElement("img");
            img.className = "inline-img";
            img.alt = p.value;
            img.decoding = "async";
            img.loading = "lazy";
            const url = URL.createObjectURL(rec.blob);
            img.src = url;
            img.addEventListener("load", () => setTimeout(() => URL.revokeObjectURL(url), 8000), { once:true });
            flow.appendChild(img);
          }
        }catch{}
      }
    }

    if (!flow.childNodes.length){
      const block = document.createElement("div");
      block.className = "main-text";
      block.textContent = "";
      flow.appendChild(block);
    }

    targetEl.appendChild(flow);
  }

  function setDots(container, difficulty){
    const dots = [...container.querySelectorAll(".dot")];
    dots.forEach((d, i) => d.classList.toggle("filled", i < difficulty));
  }

  function setEmptyUI(isEmpty){
    emptyState.style.display = isEmpty ? "block" : "none";
    cardWrap.style.display = isEmpty ? "none" : "block";
    prevBtn.disabled = isEmpty;
    nextBtn.disabled = isEmpty;
  }

  function clampIndex(){
    if (idx < 0) idx = 0;
    if (idx >= cards.length) idx = Math.max(0, cards.length - 1);
  }

  function updateNavButtons(){
    prevBtn.disabled = !cards.length || idx <= 0;
    nextBtn.disabled = !cards.length || idx >= cards.length - 1;
  }

  async function renderCard(){
    if (!cards.length){
      setEmptyUI(true);
      statusLeft.textContent = "Offline • Lokal gespeichert";
      return;
    }
    setEmptyUI(false);
    clampIndex();
    updateNavButtons();

    const c = cards[idx] || {};
    const topic = (c.thema || "—").trim() || "—";
    topicFront.textContent = topic;
    topicBack.textContent = topic;

    const qText = (c.text || "").trim();
    const aTitle = (c.loesungstitel || "").trim();
    const aTextRaw = (c.loesung || "").trim();
    const answerCombined = (aTitle ? (aTitle + "\n\n") : "") + aTextRaw;

    setDots(diffFront, c.schwierigkeit || 1);
    setDots(diffBack, c.schwierigkeit || 1);

    metaFront.textContent = `Karte ${idx+1} / ${cards.length}` + (c.frageNr ? ` • Frage: ${c.frageNr}` : "");
    metaBack.textContent  = `Karte ${idx+1} / ${cards.length}` + (c.frageNr ? ` • Frage: ${c.frageNr}` : "");

    if (isFlipped){
      isFlipped = false;
      cardEl.classList.remove("flipped");
    }

    // reset scroll positions (important on mobile)
    scrollFront.scrollTop = 0;
    scrollBack.scrollTop = 0;

    await renderMixedFlow(textFront, qText);
    await renderMixedFlow(textBack, answerCombined);

    const meta = txtList.find(t => t.id === currentTxtId);
    const imgCount = meta?.imgCount || 0;
    statusLeft.textContent = `Offline • TXT: ${currentTxtName || "—"} • Bilder: ${imgCount}`;
  }

  // IMPORTANT FIX:
  // iOS sometimes interprets a scroll as a click => flip.
  // So we only flip if the user didn't start the gesture inside a scroll area.
  let pointerStartedInScroll = false;

  function isInsideScroll(el){
    return !!(el && (el.closest && el.closest(".scroll")));
  }

  cardEl.addEventListener("pointerdown", (e) => {
    pointerStartedInScroll = isInsideScroll(e.target);
  }, { passive:true });

  cardEl.addEventListener("click", (e) => {
    if (isInsideScroll(e.target) || pointerStartedInScroll){
      pointerStartedInScroll = false;
      return; // don't flip when user scrolls
    }
    flip();
  });

  cardEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " "){
      e.preventDefault();
      flip();
    }
  });

  function flip(){
    if (!cards.length) return;
    isFlipped = !isFlipped;
    cardEl.classList.toggle("flipped", isFlipped);
  }

  // ---------- Theme ----------
  function setThemeIcon(){
    const cur = document.documentElement.getAttribute("data-theme") || "light";
    themeIcon.innerHTML = (cur === "dark") ? svgSun() : svgMoonStars();
  }
  function applyTheme(theme){
    const t = theme === "dark" ? "dark" : "light";
    document.documentElement.setAttribute("data-theme", t);
    localStorage.setItem(LS_THEME_KEY, t);
    setThemeIcon();
  }
  btnTheme.addEventListener("click", () => {
    const cur = document.documentElement.getAttribute("data-theme") || "light";
    applyTheme(cur === "dark" ? "light" : "dark");
  });

  // ---------- Dropdown ----------
  function closeDD(){ dd.classList.remove("open"); ddBtn.setAttribute("aria-expanded", "false"); }
  function openDD(){ dd.classList.add("open"); ddBtn.setAttribute("aria-expanded", "true"); }
  ddBtn.addEventListener("click", () => dd.classList.contains("open") ? closeDD() : openDD());
  window.addEventListener("click", (e) => { if (!dd.contains(e.target)) closeDD(); });
  window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeDD(); });

  function setDDHeader(){
    if (!currentTxtId){
      ddTitle.textContent = "Keine TXT geladen";
      ddMeta.textContent = "";
      return;
    }
    const meta = txtList.find(t => t.id === currentTxtId);
    ddTitle.textContent = currentTxtName || "—";
    ddMeta.textContent = `${cards.length} Karten • ${(meta?.imgCount || 0)} Bilder`;
  }

  async function refreshTxtMetaFromDB(){
    for (const t of txtList){
      try{
        const c = await idbCountImagesForTxt(t.id);
        t.imgCount = c;
        t.hasImages = c > 0;
      }catch{
        t.imgCount = t.imgCount || 0;
        t.hasImages = (t.imgCount || 0) > 0;
      }
    }
    saveTxtList();
  }

  // ---------- Image Modal ----------
  let modalTxtId = "";

  function openImgModal(txtId){
    modalTxtId = txtId;
    const meta = txtList.find(t => t.id === txtId);
    imgModalTitle.textContent = `Bilder: ${meta?.name || "—"}`;
    imgModalBackdrop.classList.add("open");
    imgModalBackdrop.setAttribute("aria-hidden", "false");
    renderImgModal();
  }

  function closeImgModal(){
    imgModalBackdrop.classList.remove("open");
    imgModalBackdrop.setAttribute("aria-hidden", "true");
    modalTxtId = "";
  }

  btnCloseImgModal.addEventListener("click", closeImgModal);
  imgModalBackdrop.addEventListener("click", (e) => {
    if (e.target === imgModalBackdrop) closeImgModal();
  });

  async function renderImgModal(){
    if (!modalTxtId) return;
    imgModalBody.innerHTML = "";

    const list = await idbListImagesForTxt(modalTxtId);
    list.sort((a,b) => (a.name || "").localeCompare(b.name || ""));

    imgModalCount.textContent = `${list.length} Bilder gespeichert`;

    if (!list.length){
      const div = document.createElement("div");
      div.style.color = "var(--muted)";
      div.style.fontSize = "13px";
      div.style.padding = "6px 2px";
      div.textContent = "Noch keine Bilder für diese TXT.";
      imgModalBody.appendChild(div);
      return;
    }

    for (const rec of list){
      const row = document.createElement("div");
      row.className = "img-row";

      const thumb = document.createElement("img");
      thumb.className = "img-thumb";
      thumb.alt = rec.name;
      const url = URL.createObjectURL(rec.blob);
      thumb.src = url;
      thumb.addEventListener("load", () => setTimeout(() => URL.revokeObjectURL(url), 7000), { once:true });

      const info = document.createElement("div");
      info.className = "img-info";

      const name = document.createElement("div");
      name.className = "img-name";
      name.textContent = rec.name;

      const sub = document.createElement("div");
      sub.className = "img-sub";
      sub.textContent = `Marker: #${rec.name}#`;

      info.appendChild(name);
      info.appendChild(sub);

      const del = document.createElement("button");
      del.className = "mini danger";
      del.type = "button";
      del.title = "Bild löschen";
      del.innerHTML = svgTrash();
      del.addEventListener("click", async () => {
        const ok = confirm(`Bild "${rec.name}" löschen?`);
        if (!ok) return;
        await idbDeleteImage(modalTxtId, rec.name);
        await refreshTxtMetaFromDB();
        renderDDList();
        setDDHeader();
        await renderImgModal();
        if (modalTxtId === currentTxtId) await renderCard();
      });

      row.appendChild(thumb);
      row.appendChild(info);
      row.appendChild(del);
      imgModalBody.appendChild(row);
    }
  }

  // modal buttons icons
  addImgIcon.innerHTML = svgPhoto();
  trashAllIcon.innerHTML = svgTrash();
  closeIcon.innerHTML = svgClose();

  let pendingImageUploadTxtId = null;

  btnAddImagesModal.addEventListener("click", () => {
    if (!modalTxtId) return;
    pendingImageUploadTxtId = modalTxtId;
    imgInput.click();
  });

  btnDeleteAllImages.addEventListener("click", async () => {
    if (!modalTxtId) return;
    const ok = confirm("Wirklich ALLE Bilder dieser TXT löschen?");
    if (!ok) return;

    await idbDeleteImagesForTxt(modalTxtId);
    await refreshTxtMetaFromDB();
    renderDDList();
    setDDHeader();
    await renderImgModal();
    if (modalTxtId === currentTxtId) await renderCard();
  });

  // ---------- Dropdown list rendering ----------
  function renderDDList(){
    ddList.innerHTML = "";

    if (!txtList.length){
      const div = document.createElement("div");
      div.style.padding = "14px";
      div.style.color = "var(--muted)";
      div.style.fontSize = "13px";
      div.textContent = "Noch keine TXT gespeichert.";
      ddList.appendChild(div);
      return;
    }

    for (const t of txtList){
      const item = document.createElement("div");
      item.className = "dd-item";

      const main = document.createElement("div");
      main.className = "dd-item-main";

      const title = document.createElement("div");
      title.className = "dd-item-title";

      const name = document.createElement("div");
      name.className = "tname";
      name.textContent = t.name;
      title.appendChild(name);

      if (t.hasImages){
        const badgeWrap = document.createElement("div");
        badgeWrap.innerHTML = badgeImages();
        title.appendChild(badgeWrap.firstElementChild);
      }

      const sub = document.createElement("div");
      sub.className = "dd-item-sub";
      sub.textContent = `Bilder: ${t.imgCount || 0} • hinzugefügt: ${new Date(t.addedAt || Date.now()).toLocaleDateString()}`;

      main.appendChild(title);
      main.appendChild(sub);

      main.addEventListener("click", async () => {
        await selectTxt(t.id);
        closeDD();
      });

      const actions = document.createElement("div");
      actions.className = "dd-actions";

      // Image manager button -> opens modal
      const btnImg = document.createElement("button");
      btnImg.className = "mini";
      btnImg.type = "button";
      btnImg.title = "Bilder verwalten";
      btnImg.innerHTML = svgPhoto();
      btnImg.addEventListener("click", async (ev) => {
        ev.stopPropagation();
        openImgModal(t.id);
      });

      // Delete TXT button
      const btnDel = document.createElement("button");
      btnDel.className = "mini danger";
      btnDel.type = "button";
      btnDel.title = "TXT + Bilder löschen";
      btnDel.innerHTML = svgTrash();
      btnDel.addEventListener("click", async (ev) => {
        ev.stopPropagation();
        await deleteTxt(t.id);
      });

      actions.appendChild(btnImg);
      actions.appendChild(btnDel);

      item.appendChild(main);
      item.appendChild(actions);
      ddList.appendChild(item);
    }
  }

  // ---------- Select TXT ----------
  async function selectTxt(id){
    currentTxtId = id || "";
    const meta = txtList.find(t => t.id === currentTxtId);
    currentTxtName = meta ? meta.name : "";

    if (!currentTxtId){
      cards = [];
      idx = 0;
      setDDHeader();
      await renderCard();
      return;
    }

    localStorage.setItem(LS_LAST_TXT_KEY, currentTxtId);
    const content = getTxtContent(currentTxtId);
    cards = parseTXT(content);
    idx = 0;

    setDDHeader();
    await renderCard();
  }

  // ---------- Upload TXT ----------
  btnUploadTxt.addEventListener("click", () => txtInput.click());
  txtInput.addEventListener("change", async () => {
    const files = [...(txtInput.files || [])].filter(f => f);
    if (!files.length) return;

    for (const f of files){
      const text = await f.text();
      const id = makeId();
      txtList.unshift({ id, name: f.name || "Upload.txt", addedAt: Date.now(), hasImages:false, imgCount:0 });
      saveTxtContent(id, text);
    }

    saveTxtList();
    await refreshTxtMetaFromDB();
    renderDDList();
    await selectTxt(txtList[0].id);
    closeDD();
    txtInput.value = "";
  });

  // ---------- Upload Images ----------
  function filenameNoExt(name){
    const s = String(name || "");
    const base = s.split("/").pop().split("\\").pop();
    const dot = base.lastIndexOf(".");
    return (dot > 0 ? base.slice(0, dot) : base).trim();
  }

  imgInput.addEventListener("change", async () => {
    const files = [...(imgInput.files || [])].filter(f => f && f.type && f.type.startsWith("image/"));
    if (!files.length) return;

    const txtId = pendingImageUploadTxtId || currentTxtId;
    if (!txtId) return;

    for (const f of files){
      const markerName = filenameNoExt(f.name).toLowerCase();
      if (!markerName) continue;
      await idbPutImage(txtId, markerName, f.slice(0, f.size, f.type), f.type);
    }

    pendingImageUploadTxtId = null;
    imgInput.value = "";

    await refreshTxtMetaFromDB();
    renderDDList();
    setDDHeader();

    if (imgModalBackdrop.classList.contains("open")) await renderImgModal();
    if (txtId === currentTxtId) await renderCard();
  });

  // ---------- Delete TXT ----------
  async function deleteTxt(txtId){
    const meta = txtList.find(t => t.id === txtId);
    const name = meta?.name || txtId;
    const ok = confirm(`TXT "${name}" wirklich löschen?\n(inkl. aller zugehörigen Bilder)`);
    if (!ok) return;

    deleteTxtContent(txtId);
    txtList = txtList.filter(t => t.id !== txtId);
    saveTxtList();

    await idbDeleteImagesForTxt(txtId);

    await refreshTxtMetaFromDB();
    renderDDList();

    if (currentTxtId === txtId){
      const nextId = txtList[0]?.id || "";
      await selectTxt(nextId);
    } else {
      setDDHeader();
      await renderCard();
    }
  }

  // ---------- Navigation ----------
  prevBtn.addEventListener("click", async () => { if (idx > 0){ idx--; await renderCard(); } });
  nextBtn.addEventListener("click", async () => { if (idx < cards.length - 1){ idx++; await renderCard(); } });

  window.addEventListener("keydown", async (e) => {
    if (e.key === "ArrowLeft"){ if (idx > 0){ idx--; await renderCard(); } }
    else if (e.key === "ArrowRight"){ if (idx < cards.length - 1){ idx++; await renderCard(); } }
    else if (e.key === "Escape") flip();
  });

  // ---------- Init ----------
  async function init(){
    applyTheme(localStorage.getItem(LS_THEME_KEY) || "light");

    loadTxtList();
    await refreshTxtMetaFromDB();
    renderDDList();

    const last = localStorage.getItem(LS_LAST_TXT_KEY) || "";
    const initialId = (last && txtList.some(t => t.id === last)) ? last : (txtList[0]?.id || "");
    await selectTxt(initialId);

    setDDHeader();
    setThemeIcon();
  }

  init();
})();
</script>
</body>
</html>